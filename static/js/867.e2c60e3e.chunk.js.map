{"version":3,"file":"static/js/867.e2c60e3e.chunk.js","mappings":"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","sources":["../node_modules/@ethersproject/networks/src.ts/index.ts","../node_modules/@ethersproject/networks/src.ts/_version.ts","../node_modules/@ethersproject/basex/src.ts/index.ts","../node_modules/@ethersproject/strings/src.ts/idna.ts","../node_modules/@ethersproject/hash/src.ts/_version.ts","../node_modules/@ethersproject/hash/src.ts/namehash.ts","../node_modules/@ethersproject/sha2/src.ts/browser-sha2.ts","../node_modules/@ethersproject/sha2/src.ts/_version.ts","../node_modules/@ethersproject/base64/src.ts/browser-base64.ts","../node_modules/@ethersproject/web/src.ts/_version.ts","../node_modules/@ethersproject/web/src.ts/browser-geturl.ts","../node_modules/@ethersproject/web/src.ts/index.ts","../node_modules/@ethersproject/providers/src.ts/_version.ts","../node_modules/@ethersproject/providers/src.ts/formatter.ts","../node_modules/@ethersproject/constants/src.ts/addresses.ts","../node_modules/@ethersproject/providers/src.ts/base-provider.ts","../node_modules/@ethersproject/constants/src.ts/hashes.ts","../node_modules/@ethersproject/hash/src.ts/typed-data.ts","../node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts","../node_modules/@ethersproject/providers/src.ts/browser-ws.ts","../node_modules/@ethersproject/providers/src.ts/websocket-provider.ts","../node_modules/@ethersproject/providers/src.ts/url-json-rpc-provider.ts","../node_modules/@ethersproject/providers/src.ts/alchemy-provider.ts","../node_modules/@ethersproject/providers/src.ts/cloudflare-provider.ts","../node_modules/@ethersproject/providers/src.ts/etherscan-provider.ts","../node_modules/@ethersproject/random/src.ts/shuffle.ts","../node_modules/@ethersproject/providers/src.ts/fallback-provider.ts","../node_modules/@ethersproject/providers/src.ts/browser-ipc-provider.ts","../node_modules/@ethersproject/providers/src.ts/infura-provider.ts","../node_modules/@ethersproject/providers/src.ts/json-rpc-batch-provider.ts","../node_modules/@ethersproject/providers/src.ts/nodesmith-provider.ts","../node_modules/@ethersproject/providers/src.ts/pocket-provider.ts","../node_modules/@ethersproject/providers/src.ts/web3-provider.ts","../node_modules/@ethersproject/providers/src.ts/index.ts","../node_modules/bech32/index.js"],"sourcesContent":["\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Network, Networkish } from \"./types\";\n\nexport {\n    Network,\n    Networkish\n};\n\ntype DefaultProviderFunc = (providers: any, options?: any) => any;\n\ninterface Renetworkable extends DefaultProviderFunc {\n    renetwork: (network: Network) => DefaultProviderFunc;\n};\n\nfunction isRenetworkable(value: any): value is Renetworkable {\n    return (value && typeof(value.renetwork) === \"function\");\n}\n\nfunction ethDefaultProvider(network: string | Network): Renetworkable {\n    const func = function(providers: any, options?: any): any {\n        if (options == null) { options = { }; }\n        const providerList: Array<any> = [];\n\n        if (providers.InfuraProvider) {\n            try {\n                providerList.push(new providers.InfuraProvider(network, options.infura));\n            } catch(error) { }\n        }\n\n        if (providers.EtherscanProvider) {\n            try {\n                providerList.push(new providers.EtherscanProvider(network, options.etherscan));\n            } catch(error) { }\n        }\n\n        if (providers.AlchemyProvider) {\n            try {\n                providerList.push(new providers.AlchemyProvider(network, options.alchemy));\n            } catch(error) { }\n        }\n\n        if (providers.PocketProvider) {\n            // These networks are currently faulty on Pocket as their\n            // network does not handle the Berlin hardfork, which is\n            // live on these ones.\n            // @TODO: This goes away once Pocket has upgraded their nodes\n            const skip = [ \"goerli\", \"ropsten\", \"rinkeby\" ];\n            try {\n                const provider = new providers.PocketProvider(network);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            } catch(error) { }\n        }\n\n        if (providers.CloudflareProvider) {\n            try {\n                providerList.push(new providers.CloudflareProvider(network));\n            } catch(error) { }\n        }\n\n        if (providerList.length === 0) { return null; }\n\n        if (providers.FallbackProvider) {\n            let quorum = 1;\n            if (options.quorum != null) {\n                quorum = options.quorum;\n            } else if (network === \"homestead\") {\n                quorum = 2;\n            }\n            return new providers.FallbackProvider(providerList, quorum);\n        }\n\n        return providerList[0];\n    };\n\n    func.renetwork = function(network: Network) {\n        return ethDefaultProvider(network);\n    };\n\n    return func;\n}\n\nfunction etcDefaultProvider(url: string, network: string | Network): Renetworkable {\n    const func = function(providers: any, options?: any): any {\n        if (providers.JsonRpcProvider) {\n            return new providers.JsonRpcProvider(url, network);\n        }\n\n        return null;\n    };\n\n    func.renetwork = function(network: Network) {\n        return etcDefaultProvider(url, network);\n    };\n\n    return func;\n}\n\nconst homestead: Network = {\n    chainId: 1,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"homestead\",\n    _defaultProvider: ethDefaultProvider(\"homestead\")\n};\n\nconst ropsten: Network = {\n    chainId: 3,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"ropsten\",\n    _defaultProvider: ethDefaultProvider(\"ropsten\")\n};\n\nconst classicMordor: Network = {\n    chainId: 63,\n    name: \"classicMordor\",\n    _defaultProvider: etcDefaultProvider(\"https://www.ethercluster.com/mordor\", \"classicMordor\")\n};\n\n// See: https://chainlist.org\nconst networks: { [name: string]: Network } = {\n    unspecified: { chainId: 0, name: \"unspecified\" },\n\n    homestead: homestead,\n    mainnet: homestead,\n\n    morden: { chainId: 2, name: \"morden\" },\n\n    ropsten: ropsten,\n    testnet: ropsten,\n\n    rinkeby: {\n        chainId: 4,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"rinkeby\",\n        _defaultProvider: ethDefaultProvider(\"rinkeby\")\n    },\n\n    kovan: {\n        chainId: 42,\n        name: \"kovan\",\n        _defaultProvider: ethDefaultProvider(\"kovan\")\n    },\n\n    goerli: {\n        chainId: 5,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"goerli\",\n        _defaultProvider: ethDefaultProvider(\"goerli\")\n    },\n\n    kintsugi: { chainId: 1337702, name: \"kintsugi\" },\n\n\n    // ETC (See: #351)\n    classic: {\n        chainId: 61,\n        name: \"classic\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/etc\", \"classic\")\n    },\n\n    classicMorden: { chainId: 62, name: \"classicMorden\" },\n\n    classicMordor: classicMordor,\n    classicTestnet: classicMordor,\n\n    classicKotti: {\n        chainId: 6,\n        name: \"classicKotti\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/kotti\", \"classicKotti\")\n    },\n\n    xdai: { chainId: 100, name: \"xdai\" },\n\n    matic: { chainId: 137, name: \"matic\" },\n    maticmum: { chainId: 80001, name: \"maticmum\" },\n\n    optimism: { chainId: 10, name: \"optimism\" },\n    \"optimism-kovan\": { chainId: 69, name: \"optimism-kovan\" },\n    \"optimism-goerli\": { chainId: 420, name: \"optimism-goerli\" },\n\n    arbitrum: { chainId: 42161, name: \"arbitrum\" },\n    \"arbitrum-rinkeby\": { chainId: 421611, name: \"arbitrum-rinkeby\" },\n\n    bnb: { chainId: 56, name: \"bnb\" },\n    bnbt: { chainId: 97, name: \"bnbt\" },\n}\n\n/**\n *  getNetwork\n *\n *  Converts a named common networks or chain ID (network ID) to a Network\n *  and verifies a network is a valid Network..\n */\nexport function getNetwork(network: Networkish): Network {\n    // No network (null)\n    if (network == null) { return null; }\n\n    if (typeof(network) === \"number\") {\n        for (const name in networks) {\n            const standard = networks[name];\n            if (standard.chainId === network) {\n                return {\n                    name: standard.name,\n                    chainId: standard.chainId,\n                    ensAddress: (standard.ensAddress || null),\n                    _defaultProvider: (standard._defaultProvider || null)\n                };\n            }\n        }\n\n        return {\n            chainId: network,\n            name: \"unknown\"\n        };\n    }\n\n    if (typeof(network) === \"string\") {\n        const standard = networks[network];\n        if (standard == null) { return null; }\n        return {\n            name: standard.name,\n            chainId: standard.chainId,\n            ensAddress: standard.ensAddress,\n            _defaultProvider: (standard._defaultProvider || null)\n        };\n    }\n\n    const standard  = networks[network.name];\n\n    // Not a standard network; check that it is a valid network in general\n    if (!standard) {\n        if (typeof(network.chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid network chainId\", \"network\", network);\n        }\n        return network;\n    }\n\n    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)\n    if (network.chainId !== 0 && network.chainId !== standard.chainId) {\n        logger.throwArgumentError(\"network chainId mismatch\", \"network\", network);\n    }\n\n    // @TODO: In the next major version add an attach function to a defaultProvider\n    // class and move the _defaultProvider internal to this file (extend Network)\n    let defaultProvider: DefaultProviderFunc = network._defaultProvider || null;\n    if (defaultProvider == null && standard._defaultProvider) {\n        if (isRenetworkable(standard._defaultProvider)) {\n            defaultProvider = standard._defaultProvider.renetwork(network);\n        } else {\n            defaultProvider = standard._defaultProvider;\n        }\n    }\n\n    // Standard Network (allow overriding the ENS address)\n    return {\n        name: network.name,\n        chainId: standard.chainId,\n        ensAddress: (network.ensAddress || standard.ensAddress || null),\n        _defaultProvider: defaultProvider\n    };\n}\n","export const version = \"networks/5.5.2\";\n","/**\n * var basex = require(\"base-x\");\n *\n * This implementation is heavily based on base-x. The main reason to\n * deviate was to prevent the dependency of Buffer.\n *\n * Contributors:\n *\n * base-x encoding\n * Forked from https://github.com/cryptocoinjs/bs58\n * Originally written by Mike Hearn for BitcoinJ\n * Copyright (c) 2011 Google Inc\n * Ported to JavaScript by Stefan Thomas\n * Merged Buffer refactorings from base58-native by Stephen Pair\n * Copyright (c) 2013 BitPay Inc\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nexport class BaseX {\n    readonly alphabet: string;\n    readonly base: number;\n\n    _alphabetMap: { [ character: string ]: number };\n    _leader: string;\n\n    constructor(alphabet: string) {\n        defineReadOnly(this, \"alphabet\", alphabet);\n        defineReadOnly(this, \"base\", alphabet.length);\n\n        defineReadOnly(this, \"_alphabetMap\", { });\n        defineReadOnly(this, \"_leader\", alphabet.charAt(0));\n\n        // pre-compute lookup table\n        for (let i = 0; i < alphabet.length; i++) {\n            this._alphabetMap[alphabet.charAt(i)] = i;\n        }\n    }\n\n    encode(value: BytesLike): string {\n        let source = arrayify(value);\n\n        if (source.length === 0) { return \"\"; }\n\n        let digits = [ 0 ]\n        for (let i = 0; i < source.length; ++i) {\n            let carry = source[i];\n            for (let j = 0; j < digits.length; ++j) {\n                carry += digits[j] << 8;\n                digits[j] = carry % this.base;\n                carry = (carry / this.base) | 0;\n            }\n\n            while (carry > 0) {\n                digits.push(carry % this.base);\n                carry = (carry / this.base) | 0;\n            }\n        }\n\n        let string = \"\"\n\n        // deal with leading zeros\n        for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {\n            string += this._leader;\n        }\n\n        // convert digits to a string\n        for (let q = digits.length - 1; q >= 0; --q) {\n            string += this.alphabet[digits[q]];\n        }\n\n        return string;\n    }\n\n    decode(value: string): Uint8Array {\n        if (typeof(value) !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n\n        let bytes: Array<number> = [];\n        if (value.length === 0) { return new Uint8Array(bytes); }\n\n        bytes.push(0);\n        for (let i = 0; i < value.length; i++) {\n            let byte = this._alphabetMap[value[i]];\n\n            if (byte === undefined) {\n                throw new Error(\"Non-base\" + this.base + \" character\");\n            }\n\n            let carry = byte;\n            for (let j = 0; j < bytes.length; ++j) {\n                carry += bytes[j] * this.base;\n                bytes[j] = carry & 0xff;\n                carry >>= 8;\n            }\n\n            while (carry > 0) {\n                bytes.push(carry & 0xff);\n                carry >>= 8;\n            }\n        }\n\n        // deal with leading zeros\n        for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {\n            bytes.push(0)\n        }\n\n        return arrayify(new Uint8Array(bytes.reverse()))\n    }\n}\n\nconst Base32 = new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");\nconst Base58 = new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\n\nexport { Base32, Base58 };\n\n//console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n//console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))\n","\"use strict\";\n\nimport { toUtf8CodePoints, _toUtf8String, UnicodeNormalizationForm } from \"./utf8\";\n\ntype Ranged = {\n    l: number,          // Lo value\n    h: number,          // High value (less the lo)\n    d?: number,         // Delta/stride (default: 1)\n    s?: number,         // Shift (default: 1)\n    e?: Array<number>   // Exceptions to skip\n};\n\ntype Table = { [ src: number ]: Array<number> };\n\nfunction bytes2(data: string): Array<number> {\n    if ((data.length % 4) !== 0) { throw new Error(\"bad data\"); }\n    let result = [];\n    for (let i = 0; i < data.length; i += 4) {\n        result.push(parseInt(data.substring(i, i + 4), 16));\n    }\n    return result;\n}\n\nfunction createTable(data: string, func?: (value: string) => Array<number>): Table {\n    if (!func) {\n        func = function(value: string) { return [ parseInt(value, 16) ]; }\n    }\n\n    let lo = 0;\n\n    let result: Table = { };\n    data.split(\",\").forEach((pair) => {\n        let comps = pair.split(\":\");\n        lo += parseInt(comps[0], 16);\n        result[lo] = func(comps[1]);\n    });\n\n    return result;\n}\n\nfunction createRangeTable(data: string): Array<Ranged> {\n    let hi = 0;\n    return data.split(\",\").map((v) => {\n        let comps = v.split(\"-\");\n        if (comps.length === 1) {\n            comps[1] = \"0\";\n        } else if (comps[1] === \"\") {\n            comps[1] = \"1\";\n        }\n\n        let lo = hi + parseInt(comps[0], 16);\n        hi = parseInt(comps[1], 16);\n        return { l: lo, h: hi };\n    });\n}\n\nfunction matchMap(value: number, ranges: Array<Ranged>): Ranged {\n    let lo = 0;\n    for (let i = 0; i < ranges.length; i++) {\n        let range = ranges[i];\n        lo += range.l;\n        if (value >= lo && value <= lo + range.h && ((value - lo) % (range.d || 1)) === 0) {\n            if (range.e && range.e.indexOf(value - lo) !== -1) { continue; }\n            return range;\n        }\n    }\n    return null;\n}\n\nconst Table_A_1_ranges = createRangeTable(\"221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d\");\n\n// @TODO: Make this relative...\nconst Table_B_1_flags = \"ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff\".split(\",\").map((v) => parseInt(v, 16));\n\nconst Table_B_2_ranges: Array<Ranged> = [\n    { h: 25, s: 32, l: 65 },\n    { h: 30, s: 32, e: [ 23 ], l: 127 },\n    { h: 54, s: 1, e: [ 48 ], l: 64, d: 2 },\n    { h: 14, s: 1, l: 57, d: 2 },\n    { h: 44, s: 1, l: 17, d: 2 },\n    { h: 10, s: 1, e: [ 2, 6, 8 ], l: 61, d: 2 },\n    { h: 16, s: 1, l: 68, d: 2 },\n    { h: 84, s: 1, e: [ 18, 24, 66 ], l: 19, d: 2 },\n    { h: 26, s: 32, e: [ 17 ], l: 435 },\n    { h: 22, s: 1, l: 71, d: 2 },\n    { h: 15, s: 80, l: 40 },\n    { h: 31, s: 32, l: 16 },\n    { h: 32, s: 1, l: 80, d: 2 },\n    { h: 52, s: 1, l: 42, d: 2 },\n    { h: 12, s: 1, l: 55, d: 2 },\n    { h: 40, s: 1, e: [ 38 ], l: 15, d: 2 },\n    { h: 14, s: 1, l: 48, d: 2 },\n    { h: 37, s: 48, l: 49 },\n    { h: 148, s: 1, l: 6351, d: 2 },\n    { h: 88, s: 1, l: 160, d: 2 },\n    { h: 15, s: 16, l: 704 },\n    { h: 25, s: 26, l: 854 },\n    { h: 25, s: 32, l: 55915 },\n    { h: 37, s: 40, l: 1247 },\n    { h: 25, s: -119711, l: 53248 },\n    { h: 25, s: -119763, l: 52 },\n    { h: 25, s: -119815, l: 52 },\n    { h: 25, s: -119867, e: [ 1, 4, 5, 7, 8, 11, 12, 17 ], l: 52 },\n    { h: 25, s: -119919, l: 52 },\n    { h: 24, s: -119971, e: [ 2, 7, 8, 17 ], l: 52 },\n    { h: 24, s: -120023, e: [ 2, 7, 13, 15, 16, 17 ], l: 52 },\n    { h: 25, s: -120075, l: 52 },\n    { h: 25, s: -120127, l: 52 },\n    { h: 25, s: -120179, l: 52 },\n    { h: 25, s: -120231, l: 52 },\n    { h: 25, s: -120283, l: 52 },\n    { h: 25, s: -120335, l: 52 },\n    { h: 24, s: -119543, e: [ 17 ], l: 56 },\n    { h: 24, s: -119601, e: [ 17 ], l: 58 },\n    { h: 24, s: -119659, e: [ 17 ], l: 58 },\n    { h: 24, s: -119717, e: [ 17 ], l: 58 },\n    { h: 24, s: -119775, e: [ 17 ], l: 58 }\n];\nconst Table_B_2_lut_abs = createTable(\"b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3\");\nconst Table_B_2_lut_rel = createTable(\"179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7\");\nconst Table_B_2_complex = createTable(\"df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D\", bytes2);\n\nconst Table_C_ranges = createRangeTable(\"80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001\");\n\n\nfunction flatten(values: Array<Array<number>>): Array<number> {\n    return values.reduce((accum, value) => {\n        value.forEach((value) => { accum.push(value); });\n        return accum;\n    }, [ ]);\n}\n\nexport function _nameprepTableA1(codepoint: number): boolean {\n    return !!matchMap(codepoint, Table_A_1_ranges);\n}\n\nexport function _nameprepTableB2(codepoint: number): Array<number> {\n    let range = matchMap(codepoint, Table_B_2_ranges);\n    if (range) { return [ codepoint + range.s ]; }\n\n    let codes = Table_B_2_lut_abs[codepoint];\n    if (codes) { return codes; }\n\n    let shift = Table_B_2_lut_rel[codepoint];\n    if (shift) { return [ codepoint + shift[0] ]; }\n\n    let complex = Table_B_2_complex[codepoint];\n    if (complex) { return complex; }\n\n    return null;\n}\n\nexport function _nameprepTableC(codepoint: number): boolean {\n    return !!matchMap(codepoint, Table_C_ranges);\n}\n\nexport function nameprep(value: string): string {\n\n    // This allows platforms with incomplete normalize to bypass\n    // it for very basic names which the built-in toLowerCase\n    // will certainly handle correctly\n    if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) { return value.toLowerCase(); }\n\n    // Get the code points (keeping the current normalization)\n    let codes = toUtf8CodePoints(value);\n\n    codes = flatten(codes.map((code) => {\n        // Substitute Table B.1 (Maps to Nothing)\n        if (Table_B_1_flags.indexOf(code) >= 0) { return [ ]; }\n        if (code >= 0xfe00 && code <= 0xfe0f) { return [ ]; }\n\n        // Substitute Table B.2 (Case Folding)\n        let codesTableB2 = _nameprepTableB2(code);\n        if (codesTableB2) { return codesTableB2; }\n\n        // No Substitution\n        return [ code ];\n    }));\n\n    // Normalize using form KC\n    codes = toUtf8CodePoints(_toUtf8String(codes), UnicodeNormalizationForm.NFKC);\n\n    // Prohibit Tables C.1.2, C.2.2, C.3, C.4, C.5, C.6, C.7, C.8, C.9\n    codes.forEach((code) => {\n        if (_nameprepTableC(code)) {\n            throw new Error(\"STRINGPREP_CONTAINS_PROHIBITED\");\n        }\n    });\n\n    // Prohibit Unassigned Code Points (Table A.1)\n    codes.forEach((code) => {\n        if (_nameprepTableA1(code)) {\n            throw new Error(\"STRINGPREP_CONTAINS_UNASSIGNED\");\n        }\n    });\n\n    // IDNA extras\n    let name = _toUtf8String(codes);\n\n    // IDNA: 4.2.3.1\n    if (name.substring(0, 1) === \"-\" || name.substring(2, 4) === \"--\" || name.substring(name.length - 1) === \"-\") {\n        throw new Error(\"invalid hyphen\");\n    }\n\n    // IDNA: 4.2.4\n    if (name.length > 63) { throw new Error(\"too long\"); }\n\n\n\n    return name;\n}\n\n","export const version = \"hash/5.5.0\";\n","import { concat, hexlify } from \"@ethersproject/bytes\";\nimport { nameprep, toUtf8Bytes } from \"@ethersproject/strings\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\n\nconst Partition = new RegExp(\"^((.*)\\\\.)?([^.]+)$\");\n\nexport function isValidName(name: string): boolean {\n    try {\n        const comps = name.split(\".\");\n        for (let i = 0; i < comps.length; i++) {\n            if (nameprep(comps[i]).length === 0) {\n                throw new Error(\"empty\")\n            }\n        }\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function namehash(name: string): string {\n    /* istanbul ignore if */\n    if (typeof(name) !== \"string\") {\n        logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n    }\n\n    let current = name;\n    let result: string | Uint8Array = Zeros;\n    while (current.length) {\n        const partition = current.match(Partition);\n        if (partition == null || partition[2] === \"\") {\n            logger.throwArgumentError(\"invalid ENS address; missing component\", \"name\", name);\n        }\n        const label = toUtf8Bytes(nameprep(partition[3]));\n        result = keccak256(concat([result, keccak256(label)]));\n\n        current = partition[2] || \"\";\n    }\n\n    return hexlify(result);\n}\n\n","\"use strict\";\n\nimport hash from \"hash.js\";\n//const _ripemd160 = _hash.ripemd160;\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { SupportedAlgorithm } from \"./types\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function ripemd160(data: BytesLike): string {\n    return \"0x\" + (hash.ripemd160().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha256(data: BytesLike): string {\n    return \"0x\" + (hash.sha256().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha512(data: BytesLike): string {\n    return \"0x\" + (hash.sha512().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function computeHmac(algorithm: SupportedAlgorithm, key: BytesLike, data: BytesLike): string {\n    if (!SupportedAlgorithm[algorithm]) {\n        logger.throwError(\"unsupported algorithm \" + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"hmac\",\n            algorithm: algorithm\n        });\n    }\n\n    return \"0x\" + hash.hmac((<any>hash)[algorithm], arrayify(key)).update(arrayify(data)).digest(\"hex\");\n}\n\n","export const version = \"sha2/5.5.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function decode(textData: string): Uint8Array {\n    textData = atob(textData);\n    const data = [];\n    for (let i = 0; i < textData.length; i++) {\n        data.push(textData.charCodeAt(i));\n    }\n    return arrayify(data);\n}\n\nexport function encode(data: BytesLike): string {\n    data = arrayify(data);\n    let textData = \"\";\n    for (let i = 0; i < data.length; i++) {\n        textData += String.fromCharCode(data[i]);\n    }\n    return btoa(textData);\n}\n\n\n","export const version = \"web/5.5.1\";\n","\"use strict\";\n\nimport { arrayify } from \"@ethersproject/bytes\";\n\nimport type { GetUrlResponse, Options } from \"./types\";\n\nexport { GetUrlResponse, Options };\n\nexport async function getUrl(href: string, options?: Options): Promise<GetUrlResponse> {\n    if (options == null) { options = { }; }\n\n    const request: RequestInit = {\n        method: (options.method || \"GET\"),\n        headers: (options.headers || { }),\n        body: (options.body || undefined),\n    };\n\n    if (options.skipFetchSetup !== true) {\n        request.mode = <RequestMode>\"cors\";              // no-cors, cors, *same-origin\n        request.cache = <RequestCache>\"no-cache\";        // *default, no-cache, reload, force-cache, only-if-cached\n        request.credentials = <RequestCredentials>\"same-origin\";  // include, *same-origin, omit\n        request.redirect = <RequestRedirect>\"follow\";    // manual, *follow, error\n        request.referrer = \"client\";                     // no-referrer, *client\n    };\n\n    const response = await fetch(href, request);\n    const body = await response.arrayBuffer();\n\n    const headers: { [ name: string ]: string } = { };\n    if (response.headers.forEach) {\n        response.headers.forEach((value, key) => {\n            headers[key.toLowerCase()] = value;\n        });\n    } else {\n        (<() => Array<string>>((<any>(response.headers)).keys))().forEach((key) => {\n            headers[key.toLowerCase()] = response.headers.get(key);\n        });\n    }\n\n    return {\n        headers: headers,\n        statusCode: response.status,\n        statusMessage: response.statusText,\n        body: arrayify(new Uint8Array(body)),\n    }\n}\n","\"use strict\";\n\nimport { decode as base64Decode, encode as base64Encode } from \"@ethersproject/base64\";\nimport { hexlify, isBytesLike } from \"@ethersproject/bytes\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { getUrl, GetUrlResponse, Options } from \"./geturl\";\n\nfunction staller(duration: number): Promise<void> {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n\nfunction bodyify(value: any, type: string): string {\n    if (value == null) { return null; }\n\n    if (typeof(value) === \"string\") { return value; }\n\n    if (isBytesLike(value)) {\n        if (type && (type.split(\"/\")[0] === \"text\" || type.split(\";\")[0].trim() === \"application/json\")) {\n            try {\n                return toUtf8String(value);\n            } catch (error) { };\n        }\n        return hexlify(value);\n    }\n\n    return value;\n}\n\n// Exported Types\nexport type ConnectionInfo = {\n    url: string,\n    headers?: { [key: string]: string | number }\n\n    user?: string,\n    password?: string,\n\n    allowInsecureAuthentication?: boolean,\n    allowGzip?: boolean,\n\n    throttleLimit?: number,\n    throttleSlotInterval?: number;\n    throttleCallback?: (attempt: number, url: string) => Promise<boolean>,\n\n    timeout?: number,\n};\n\nexport interface OnceBlockable {\n    once(eventName: \"block\", handler: () => void): void;\n}\n\nexport interface OncePollable {\n    once(eventName: \"poll\", handler: () => void): void;\n}\n\nexport type PollOptions = {\n    timeout?: number,\n    floor?: number,\n    ceiling?: number,\n    interval?: number,\n    retryLimit?: number,\n    onceBlock?: OnceBlockable\n    oncePoll?: OncePollable\n};\n\nexport type FetchJsonResponse = {\n    statusCode: number;\n    headers: { [ header: string ]: string };\n};\n\n\ntype Header = { key: string, value: string };\n\n// This API is still a work in progress; the future changes will likely be:\n// - ConnectionInfo => FetchDataRequest<T = any>\n// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }\n//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)\n// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T\n// For this reason, it should be considered internal until the API is finalized\nexport function _fetchData<T = Uint8Array>(connection: string | ConnectionInfo, body?: Uint8Array, processFunc?: (value: Uint8Array, response: FetchJsonResponse) => T): Promise<T> {\n\n    // How many times to retry in the event of a throttle\n    const attemptLimit = (typeof(connection) === \"object\" && connection.throttleLimit != null) ? connection.throttleLimit: 12;\n    logger.assertArgument((attemptLimit > 0 && (attemptLimit % 1) === 0),\n        \"invalid connection throttle limit\", \"connection.throttleLimit\", attemptLimit);\n\n    const throttleCallback = ((typeof(connection) === \"object\") ? connection.throttleCallback: null);\n    const throttleSlotInterval = ((typeof(connection) === \"object\" && typeof(connection.throttleSlotInterval) === \"number\") ? connection.throttleSlotInterval: 100);\n    logger.assertArgument((throttleSlotInterval > 0 && (throttleSlotInterval % 1) === 0),\n        \"invalid connection throttle slot interval\", \"connection.throttleSlotInterval\", throttleSlotInterval);\n\n    const headers: { [key: string]: Header } = { };\n\n    let url: string = null;\n\n    // @TODO: Allow ConnectionInfo to override some of these values\n    const options: Options = {\n        method: \"GET\",\n    };\n\n    let allow304 = false;\n\n    let timeout = 2 * 60 * 1000;\n\n    if (typeof(connection) === \"string\") {\n        url = connection;\n\n    } else if (typeof(connection) === \"object\") {\n        if (connection == null || connection.url == null) {\n            logger.throwArgumentError(\"missing URL\", \"connection.url\", connection);\n        }\n\n        url = connection.url;\n\n        if (typeof(connection.timeout) === \"number\" && connection.timeout > 0) {\n            timeout = connection.timeout;\n        }\n\n        if (connection.headers) {\n            for (const key in connection.headers) {\n                headers[key.toLowerCase()] = { key: key, value: String(connection.headers[key]) };\n                if ([\"if-none-match\", \"if-modified-since\"].indexOf(key.toLowerCase()) >= 0) {\n                    allow304 = true;\n                }\n            }\n        }\n\n        options.allowGzip = !!connection.allowGzip;\n\n        if (connection.user != null && connection.password != null) {\n            if (url.substring(0, 6) !== \"https:\" && connection.allowInsecureAuthentication !== true) {\n                logger.throwError(\n                    \"basic authentication requires a secure https url\",\n                    Logger.errors.INVALID_ARGUMENT,\n                    { argument: \"url\", url: url, user: connection.user, password: \"[REDACTED]\" }\n                );\n            }\n\n            const authorization = connection.user + \":\" + connection.password;\n            headers[\"authorization\"] = {\n                key: \"Authorization\",\n                value: \"Basic \" + base64Encode(toUtf8Bytes(authorization))\n            };\n        }\n    }\n    const reData = new RegExp(\"^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$\", \"i\");\n    const dataMatch = ((url) ? url.match(reData): null);\n    if (dataMatch) {\n        try {\n            const response = {\n                statusCode: 200,\n                statusMessage: \"OK\",\n                headers: { \"content-type\": dataMatch[1] },\n                body: base64Decode(dataMatch[2])\n            };\n\n            let result: T = <T><unknown>response.body;\n            if (processFunc) {\n                result = processFunc(response.body, response);\n            }\n            return Promise.resolve(<T><unknown>result);\n\n        } catch (error) {\n            logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                body: bodyify(dataMatch[1], dataMatch[2]),\n                error: error,\n                requestBody: null,\n                requestMethod: \"GET\",\n                url: url\n            });\n        }\n    }\n\n    if (body) {\n        options.method = \"POST\";\n        options.body = body;\n        if (headers[\"content-type\"] == null) {\n            headers[\"content-type\"] = { key: \"Content-Type\", value: \"application/octet-stream\" };\n        }\n        if (headers[\"content-length\"] == null) {\n            headers[\"content-length\"] = { key: \"Content-Length\", value: String(body.length) };\n        }\n    }\n\n    const flatHeaders: { [ key: string ]: string } = { };\n    Object.keys(headers).forEach((key) => {\n        const header = headers[key];\n        flatHeaders[header.key] = header.value;\n    });\n    options.headers = flatHeaders;\n\n    const runningTimeout = (function() {\n        let timer: NodeJS.Timer = null;\n        const promise: Promise<never> = new Promise(function(resolve, reject) {\n            if (timeout) {\n                timer = setTimeout(() => {\n                    if (timer == null) { return; }\n                    timer = null;\n\n                    reject(logger.makeError(\"timeout\", Logger.errors.TIMEOUT, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        timeout: timeout,\n                        url: url\n                    }));\n                }, timeout);\n            }\n        });\n\n        const cancel = function() {\n            if (timer == null) { return; }\n            clearTimeout(timer);\n            timer = null;\n        }\n\n        return { promise, cancel };\n    })();\n\n    const runningFetch = (async function() {\n\n        for (let attempt = 0; attempt < attemptLimit; attempt++) {\n            let response: GetUrlResponse = null;\n\n            try {\n                response = await getUrl(url, options);\n\n                if (attempt < attemptLimit) {\n                    if (response.statusCode === 301 || response.statusCode === 302) {\n                        // Redirection; for now we only support absolute locataions\n                        const location = response.headers.location || \"\";\n                        if (options.method === \"GET\" && location.match(/^https:/)) {\n                            url = response.headers.location;\n                            continue;\n                        }\n\n                    } else if (response.statusCode === 429) {\n                        // Exponential back-off throttling\n                        let tryAgain = true;\n                        if (throttleCallback) {\n                            tryAgain = await throttleCallback(attempt, url);\n                        }\n\n                        if (tryAgain) {\n                            let stall = 0;\n\n                            const retryAfter = response.headers[\"retry-after\"];\n                            if (typeof(retryAfter) === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                                stall = parseInt(retryAfter) * 1000;\n                            } else {\n                                stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                            }\n\n                            //console.log(\"Stalling 429\");\n                            await staller(stall);\n                            continue;\n                        }\n                    }\n                }\n\n            } catch (error) {\n                response = (<any>error).response;\n                if (response == null) {\n                    runningTimeout.cancel();\n                    logger.throwError(\"missing response\", Logger.errors.SERVER_ERROR, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        serverError: error,\n                        url: url\n                    });\n                }\n            }\n\n\n            let body = response.body;\n\n            if (allow304 && response.statusCode === 304) {\n                body = null;\n\n            } else if (response.statusCode < 200 || response.statusCode >= 300) {\n                runningTimeout.cancel();\n                logger.throwError(\"bad response\", Logger.errors.SERVER_ERROR, {\n                    status: response.statusCode,\n                    headers: response.headers,\n                    body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"]: null)),\n                    requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                    requestMethod: options.method,\n                    url: url\n                });\n            }\n\n            if (processFunc) {\n                try {\n                    const result = await processFunc(body, response);\n                    runningTimeout.cancel();\n                    return result;\n\n                } catch (error) {\n                    // Allow the processFunc to trigger a throttle\n                    if (error.throttleRetry && attempt < attemptLimit) {\n                        let tryAgain = true;\n                        if (throttleCallback) {\n                            tryAgain = await throttleCallback(attempt, url);\n                        }\n\n                        if (tryAgain) {\n                            const timeout = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                            //console.log(\"Stalling callback\");\n                            await staller(timeout);\n                            continue;\n                        }\n                    }\n\n                    runningTimeout.cancel();\n                    logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                        body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"]: null)),\n                        error: error,\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        url: url\n                    });\n                }\n            }\n\n            runningTimeout.cancel();\n\n            // If we had a processFunc, it either returned a T or threw above.\n            // The \"body\" is now a Uint8Array.\n            return <T>(<unknown>body);\n        }\n\n        return logger.throwError(\"failed response\", Logger.errors.SERVER_ERROR, {\n            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n            requestMethod: options.method,\n            url: url\n        });\n    })();\n\n    return Promise.race([ runningTimeout.promise, runningFetch ]);\n}\n\nexport function fetchJson(connection: string | ConnectionInfo, json?: string, processFunc?: (value: any, response: FetchJsonResponse) => any): Promise<any> {\n    let processJsonFunc = (value: Uint8Array, response: FetchJsonResponse) => {\n        let result: any = null;\n        if (value != null) {\n            try {\n                result = JSON.parse(toUtf8String(value));\n            } catch (error) {\n                logger.throwError(\"invalid JSON\", Logger.errors.SERVER_ERROR, {\n                    body: value,\n                    error: error\n                });\n            }\n        }\n\n        if (processFunc) {\n            result = processFunc(result, response);\n        }\n\n        return result;\n    }\n\n    // If we have json to send, we must\n    // - add content-type of application/json (unless already overridden)\n    // - convert the json to bytes\n    let body: Uint8Array = null;\n    if (json != null) {\n        body = toUtf8Bytes(json);\n\n        // Create a connection with the content-type set for JSON\n        const updated: ConnectionInfo = (typeof(connection) === \"string\") ? ({ url: connection }): shallowCopy(connection);\n        if (updated.headers) {\n            const hasContentType = (Object.keys(updated.headers).filter((k) => (k.toLowerCase() === \"content-type\")).length) !== 0;\n            if (!hasContentType) {\n                updated.headers = shallowCopy(updated.headers);\n                updated.headers[\"content-type\"] = \"application/json\";\n            }\n        } else {\n            updated.headers = { \"content-type\": \"application/json\" };\n        }\n        connection = updated;\n    }\n\n    return _fetchData<any>(connection, body, processJsonFunc);\n}\n\nexport function poll<T>(func: () => Promise<T>, options?: PollOptions): Promise<T> {\n    if (!options) { options = {}; }\n    options = shallowCopy(options);\n    if (options.floor == null) { options.floor = 0; }\n    if (options.ceiling == null) { options.ceiling = 10000; }\n    if (options.interval == null) { options.interval = 250; }\n\n    return new Promise(function(resolve, reject) {\n\n        let timer: NodeJS.Timer = null;\n        let done: boolean = false;\n\n        // Returns true if cancel was successful. Unsuccessful cancel means we're already done.\n        const cancel = (): boolean => {\n            if (done) { return false; }\n            done = true;\n            if (timer) { clearTimeout(timer); }\n            return true;\n        };\n\n        if (options.timeout) {\n            timer = setTimeout(() => {\n                if (cancel()) { reject(new Error(\"timeout\")); }\n            }, options.timeout)\n        }\n\n        const retryLimit = options.retryLimit;\n\n        let attempt = 0;\n        function check() {\n            return func().then(function(result) {\n\n                // If we have a result, or are allowed null then we're done\n                if (result !== undefined) {\n                    if (cancel()) { resolve(result); }\n\n                } else if (options.oncePoll) {\n                    options.oncePoll.once(\"poll\", check);\n\n                } else if (options.onceBlock) {\n                    options.onceBlock.once(\"block\", check);\n\n                // Otherwise, exponential back-off (up to 10s) our next request\n                } else if (!done) {\n                    attempt++;\n                    if (attempt > retryLimit) {\n                        if (cancel()) { reject(new Error(\"retry limit reached\")); }\n                        return;\n                    }\n\n                    let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                    if (timeout < options.floor) { timeout = options.floor; }\n                    if (timeout > options.ceiling) { timeout = options.ceiling; }\n\n                    setTimeout(check, timeout);\n                }\n\n                return null;\n            }, function(error) {\n                if (cancel()) { reject(error); }\n            });\n        }\n        check();\n    });\n}\n\n","export const version = \"providers/5.5.3\";\n","\"use strict\";\n\nimport { Block, TransactionReceipt, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexDataLength, hexDataSlice, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { AccessList, accessListify, parse as parseTransaction } from \"@ethersproject/transactions\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport type FormatFunc = (value: any) => any;\n\nexport type FormatFuncs = { [ key: string ]: FormatFunc };\n\nexport type Formats = {\n    transaction: FormatFuncs,\n    transactionRequest: FormatFuncs,\n    receipt: FormatFuncs,\n    receiptLog: FormatFuncs,\n    block: FormatFuncs,\n    blockWithTransactions: FormatFuncs,\n    filter: FormatFuncs,\n    filterLog: FormatFuncs,\n};\n\nexport class Formatter {\n    readonly formats: Formats;\n\n    constructor() {\n        logger.checkNew(new.target, Formatter);\n        this.formats = this.getDefaultFormats();\n    }\n\n    getDefaultFormats(): Formats {\n        const formats: Formats = <Formats>({ });\n\n        const address = this.address.bind(this);\n        const bigNumber = this.bigNumber.bind(this);\n        const blockTag = this.blockTag.bind(this);\n        const data = this.data.bind(this);\n        const hash = this.hash.bind(this);\n        const hex = this.hex.bind(this);\n        const number = this.number.bind(this);\n        const type = this.type.bind(this);\n\n        const strictData = (v: any) => { return this.data(v, true); };\n\n        formats.transaction = {\n            hash: hash,\n\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n\n            confirmations: Formatter.allowNull(number, null),\n\n            from: address,\n\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n\n            creates: Formatter.allowNull(address, null),\n\n            raw: Formatter.allowNull(data),\n        };\n\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n        };\n\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash,\n        };\n\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),// @TODO: should this be data?\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n\n        formats.block = {\n            hash: hash,\n            parentHash: hash,\n            number: number,\n\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n\n            miner: address,\n            extraData: data,\n\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n\n        formats.blockWithTransactions = shallowCopy(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined),\n        };\n\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n\n            topics: Formatter.arrayOf(hash),\n\n            transactionHash: hash,\n            logIndex: number,\n        };\n\n        return formats;\n    }\n\n    accessList(accessList: Array<any>): AccessList {\n        return accessListify(accessList || []);\n    }\n\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    number(number: any): number {\n        if (number === \"0x\") { return 0; }\n        return BigNumber.from(number).toNumber();\n    }\n\n    type(number: any): number {\n        if (number === \"0x\" || number == null) { return 0; }\n        return BigNumber.from(number).toNumber();\n    }\n\n    // Strict! Used on input.\n    bigNumber(value: any): BigNumber {\n        return BigNumber.from(value);\n    }\n\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    boolean(value: any): boolean {\n        if (typeof(value) === \"boolean\") { return value; }\n        if (typeof(value) === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") { return true; }\n            if (value === \"false\") { return false; }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    }\n\n    hex(value: any, strict?: boolean): string {\n        if (typeof(value) === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n            if (isHexString(value)) {\n               return value.toLowerCase();\n            }\n        }\n        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    }\n\n    data(value: any, strict?: boolean): string {\n        const result = this.hex(value, strict);\n        if ((result.length % 2) !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    }\n\n    // Requires an address\n    // Strict! Used on input.\n    address(value: any): string {\n        return getAddress(value);\n    }\n\n    callAddress(value: any): string {\n        if (!isHexString(value, 32)) { return null; }\n        const address = getAddress(hexDataSlice(value, 12));\n        return (address === AddressZero) ? null: address;\n    }\n\n    contractAddress(value: any): string {\n        return getContractAddress(value);\n    }\n\n    // Strict! Used on input.\n    blockTag(blockTag: any): string {\n        if (blockTag == null) { return \"latest\"; }\n\n        if (blockTag === \"earliest\") { return \"0x0\"; }\n\n        if (blockTag === \"latest\" || blockTag === \"pending\") {\n            return blockTag;\n        }\n\n        if (typeof(blockTag) === \"number\" || isHexString(blockTag)) {\n            return hexValue(<number | string>blockTag);\n        }\n\n        throw new Error(\"invalid blockTag\");\n    }\n\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    hash(value: any, strict?: boolean): string {\n        const result = this.hex(value, strict);\n        if (hexDataLength(result) !== 32) {\n            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    }\n\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    difficulty(value: any): number {\n        if (value == null) { return null; }\n\n        const v = BigNumber.from(value);\n\n        try {\n            return v.toNumber();\n        } catch (error) { }\n\n       return null;\n    }\n\n    uint256(value: any): string {\n        if (!isHexString(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return hexZeroPad(value, 32);\n    }\n\n    _block(value: any, format: any): Block {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        // The difficulty may need to come from _difficulty in recursed blocks\n        const difficulty = (value._difficulty != null) ? value._difficulty: value.difficulty;\n        const result = Formatter.check(format, value);\n        result._difficulty = ((difficulty == null) ? null: BigNumber.from(difficulty));\n        return result;\n    }\n\n    block(value: any): Block {\n        return this._block(value, this.formats.block);\n    }\n\n    blockWithTransactions(value: any): Block {\n        return this._block(value, this.formats.blockWithTransactions);\n    }\n\n    // Strict! Used on input.\n    transactionRequest(value: any): any {\n        return Formatter.check(this.formats.transactionRequest, value);\n    }\n\n    transactionResponse(transaction: any): TransactionResponse {\n\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n\n        if ((transaction.type === 1 || transaction.type === 2)&& transaction.accessList == null) {\n            transaction.accessList = [ ];\n        }\n\n        const result: TransactionResponse = Formatter.check(this.formats.transaction, transaction);\n\n        if (transaction.chainId != null) {\n            let chainId = transaction.chainId;\n\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n\n            result.chainId = chainId;\n\n        } else {\n            let chainId = transaction.networkId;\n\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n\n            if (typeof(chainId) !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) { chainId = 0; }\n                chainId = parseInt(chainId);\n            }\n\n            if (typeof(chainId) !== \"number\") { chainId = 0; }\n\n            result.chainId = chainId;\n        }\n\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n\n        return result;\n    }\n\n    transaction(value: any): any {\n        return parseTransaction(value);\n    }\n\n    receiptLog(value: any): any {\n        return Formatter.check(this.formats.receiptLog, value);\n    }\n\n    receipt(value: any): TransactionReceipt {\n        const result: TransactionReceipt = Formatter.check(this.formats.receipt, value);\n\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                const value = BigNumber.from(result.root).toNumber();\n                if (value === 0 || value === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && (result.status !== value)) {\n                        logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", { root: result.root, status: result.status });\n                    }\n                    result.status = value;\n                    delete result.root;\n                } else {\n                    logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            } else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n\n        return result;\n    }\n\n    topics(value: any): any {\n        if (Array.isArray(value)) {\n            return value.map((v) => this.topics(v));\n\n        } else if (value != null) {\n            return this.hash(value, true);\n        }\n\n        return null;\n    }\n\n    filter(value: any): any {\n        return Formatter.check(this.formats.filter, value);\n    }\n\n    filterLog(value: any): any {\n        return Formatter.check(this.formats.filterLog, value);\n    }\n\n    static check(format: { [ name: string ]: FormatFunc }, object: any): any {\n        const result: any = {};\n        for (const key in format) {\n            try {\n                const value = format[key](object[key]);\n                if (value !== undefined) { result[key] = value; }\n            } catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    }\n\n    // if value is null-ish, nullValue is returned\n    static allowNull(format: FormatFunc, nullValue?: any): FormatFunc {\n        return (function(value: any) {\n            if (value == null) { return nullValue; }\n            return format(value);\n        });\n    }\n\n    // If value is false-ish, replaceValue is returned\n    static allowFalsish(format: FormatFunc, replaceValue: any): FormatFunc {\n        return (function(value: any) {\n            if (!value) { return replaceValue; }\n            return format(value);\n        });\n    }\n\n    // Requires an Array satisfying check\n    static arrayOf(format: FormatFunc): FormatFunc {\n        return (function(array: any): Array<any> {\n            if (!Array.isArray(array)) { throw new Error(\"not an array\"); }\n\n            const result: any = [];\n\n            array.forEach(function(value) {\n                result.push(format(value));\n            });\n\n            return result;\n        });\n    }\n}\n\nexport interface CommunityResourcable {\n    isCommunityResource(): boolean;\n}\n\nexport function isCommunityResourcable(value: any): value is CommunityResourcable {\n    return (value && typeof(value.isCommunityResource) === \"function\");\n}\n\nexport function isCommunityResource(value: any): boolean {\n    return (isCommunityResourcable(value) && value.isCommunityResource());\n}\n\n// Show the throttle message only once\nlet throttleMessage = false;\nexport function showThrottleMessage() {\n    if (throttleMessage) { return; }\n    throttleMessage = true;\n\n    console.log(\"========= NOTICE =========\")\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https:/\\/docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n}\n\n","export const AddressZero = \"0x0000000000000000000000000000000000000000\";\n\n","\"use strict\";\n\nimport {\n    Block, BlockTag, BlockWithTransactions, EventType, Filter, FilterByBlockHash, ForkEvent,\n    Listener, Log, Provider, TransactionReceipt, TransactionRequest, TransactionResponse\n} from \"@ethersproject/abstract-provider\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexConcat, hexDataLength, hexDataSlice, hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { HashZero } from \"@ethersproject/constants\";\nimport { namehash } from \"@ethersproject/hash\";\nimport { getNetwork, Network, Networkish } from \"@ethersproject/networks\";\nimport { Deferrable, defineReadOnly, getStatic, resolveProperties } from \"@ethersproject/properties\";\nimport { Transaction } from \"@ethersproject/transactions\";\nimport { sha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\n\nimport bech32 from \"bech32\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Formatter } from \"./formatter\";\n\n//////////////////////////////\n// Event Serializeing\n\nfunction checkTopic(topic: string): string {\n     if (topic == null) { return \"null\"; }\n     if (hexDataLength(topic) !== 32) {\n         logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n     }\n     return topic.toLowerCase();\n}\n\nfunction serializeTopics(topics: Array<string | Array<string>>): string {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while (topics.length > 0 && topics[topics.length - 1] == null) { topics.pop(); }\n\n    return topics.map((topic) => {\n        if (Array.isArray(topic)) {\n\n            // Only track unique OR-topics\n            const unique: { [ topic: string ]: boolean } = { }\n            topic.forEach((topic) => {\n                unique[checkTopic(topic)] = true;\n            });\n\n            // The order of OR-topics does not matter\n            const sorted = Object.keys(unique);\n            sorted.sort();\n\n            return sorted.join(\"|\");\n\n        } else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\n\nfunction deserializeTopics(data: string): Array<string | Array<string>> {\n    if (data === \"\") { return [ ]; }\n\n    return data.split(/&/g).map((topic) => {\n        if (topic === \"\") { return [ ]; }\n\n        const comps = topic.split(\"|\").map((topic) => {\n            return ((topic === \"null\") ? null: topic);\n        });\n\n        return ((comps.length === 1) ? comps[0]: comps);\n    });\n}\n\nfunction getEventTag(eventName: EventType): string {\n    if (typeof(eventName) === \"string\") {\n        eventName = eventName.toLowerCase();\n\n        if (hexDataLength(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n\n    } else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n\n    } else if (ForkEvent.isForkEvent(eventName)) {\n        logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n\n    } else if (eventName && typeof(eventName) === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n\n    throw new Error(\"invalid event - \" + eventName);\n}\n\n//////////////////////////////\n// Helper Object\n\nfunction getTime() {\n    return (new Date()).getTime();\n}\n\nfunction stall(duration: number): Promise<void> {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n\n//////////////////////////////\n// Provider Object\n\n\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */\n\nconst PollableEvents = [ \"block\", \"network\", \"pending\", \"poll\" ];\n\nexport class Event {\n    readonly listener: Listener;\n    readonly once: boolean;\n    readonly tag: string;\n\n    constructor(tag: string, listener: Listener, once: boolean) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"listener\", listener);\n        defineReadOnly(this, \"once\", once);\n    }\n\n    get event(): EventType {\n        switch (this.type) {\n            case \"tx\":\n               return this.hash;\n            case \"filter\":\n               return this.filter;\n        }\n        return this.tag;\n    }\n\n    get type(): string {\n        return this.tag.split(\":\")[0]\n    }\n\n    get hash(): string {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") { return null; }\n        return comps[1];\n    }\n\n    get filter(): Filter {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") { return null; }\n        const address = comps[1];\n\n        const topics = deserializeTopics(comps[2]);\n        const filter: Filter = { };\n\n        if (topics.length > 0) { filter.topics = topics; }\n        if (address && address !== \"*\") { filter.address = address; }\n\n        return filter;\n    }\n\n    pollable(): boolean {\n        return (this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0);\n    }\n}\n\nexport interface EnsResolver {\n\n    // Name this Resolver is associated with\n    readonly name: string;\n\n    // The address of the resolver\n    readonly address: string;\n\n    // Multichain address resolution (also normal address resolution)\n    // See: https://eips.ethereum.org/EIPS/eip-2304\n    getAddress(coinType?: 60): Promise<null | string>\n\n    // Contenthash field\n    // See: https://eips.ethereum.org/EIPS/eip-1577\n    getContentHash(): Promise<null | string>;\n\n    // Storage of text records\n    // See: https://eips.ethereum.org/EIPS/eip-634\n    getText(key: string): Promise<null | string>;\n};\n\nexport interface EnsProvider {\n    resolveName(name: string): Promise<null | string>;\n    lookupAddress(address: string): Promise<null | string>;\n    getResolver(name: string): Promise<null | EnsResolver>;\n}\n\ntype CoinInfo = {\n    symbol: string,\n    ilk?: string,     // General family\n    prefix?: string,  // Bech32 prefix\n    p2pkh?: number,   // Pay-to-Public-Key-Hash Version\n    p2sh?: number,    // Pay-to-Script-Hash Version\n};\n\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nconst coinInfos: { [ coinType: string ]: CoinInfo } = {\n    \"0\":   { symbol: \"btc\",  p2pkh: 0x00, p2sh: 0x05, prefix: \"bc\" },\n    \"2\":   { symbol: \"ltc\",  p2pkh: 0x30, p2sh: 0x32, prefix: \"ltc\" },\n    \"3\":   { symbol: \"doge\", p2pkh: 0x1e, p2sh: 0x16 },\n    \"60\":  { symbol: \"eth\",  ilk: \"eth\" },\n    \"61\":  { symbol: \"etc\",  ilk: \"eth\" },\n    \"700\": { symbol: \"xdai\", ilk: \"eth\" },\n};\n\nfunction bytes32ify(value: number): string {\n    return hexZeroPad(BigNumber.from(value).toHexString(), 32);\n}\n\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data: Uint8Array): string {\n    return Base58.encode(concat([ data, hexDataSlice(sha256(sha256(data)), 0, 4) ]));\n}\n\nexport interface Avatar {\n    url: string;\n    linkage: Array<{ type: string, content: string }>;\n}\n\nconst matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\n\nfunction _parseString(result: string): null | string {\n    try {\n        return toUtf8String(_parseBytes(result));\n    } catch(error) { }\n    return null;\n}\n\nfunction _parseBytes(result: string): null | string {\n    if (result === \"0x\") { return null; }\n\n    const offset = BigNumber.from(hexDataSlice(result, 0, 32)).toNumber();\n    const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();\n    return hexDataSlice(result, offset + 32, offset + 32 + length);\n}\n\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link: string): string {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    } else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    } else {\n        logger.throwArgumentError(\"unsupported IPFS format\", \"link\", link);\n    }\n\n    return `https:/\\/gateway.ipfs.io/ipfs/${ link }`;\n}\n\nexport class Resolver implements EnsResolver {\n    readonly provider: BaseProvider;\n\n    readonly name: string;\n    readonly address: string;\n\n    readonly _resolvedAddress: null | string;\n\n    // The resolvedAddress is only for creating a ReverseLookup resolver\n    constructor(provider: BaseProvider, address: string, name: string, resolvedAddress?: string) {\n        defineReadOnly(this, \"provider\", provider);\n        defineReadOnly(this, \"name\", name);\n        defineReadOnly(this, \"address\", provider.formatter.address(address));\n        defineReadOnly(this, \"_resolvedAddress\", resolvedAddress);\n    }\n\n    async _fetchBytes(selector: string, parameters?: string): Promise<null | string> {\n        // e.g. keccak256(\"addr(bytes32,uint256)\")\n        const tx = {\n            to: this.address,\n            data: hexConcat([ selector, namehash(this.name), (parameters || \"0x\") ])\n        };\n\n        try {\n            return _parseBytes(await this.provider.call(tx));\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n            return null;\n        }\n    }\n\n    _getAddress(coinType: number, hexBytes: string): string {\n        const coinInfo = coinInfos[String(coinType)];\n\n        if (coinInfo == null) {\n            logger.throwError(`unsupported coin type: ${ coinType }`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${ coinType })`\n            });\n        }\n\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n\n        const bytes = arrayify(hexBytes);\n\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                const length = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([ [ coinInfo.p2pkh ], (\"0x\" + p2pkh[2]) ]));\n                }\n            }\n        }\n\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                const length = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([ [ coinInfo.p2sh ], (\"0x\" + p2sh[2]) ]));\n                }\n            }\n        }\n\n        // Bech32\n        if (coinInfo.prefix != null) {\n            const length = bytes[1];\n\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            let version = bytes[0];\n            if (version === 0x00) {\n                if (length !== 20 && length !== 32) {\n                    version = -1;\n                }\n            } else {\n                version = -1;\n            }\n\n            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {\n                const words = bech32.toWords(bytes.slice(2));\n                words.unshift(version);\n                return bech32.encode(coinInfo.prefix, words);\n            }\n        }\n\n        return null;\n    }\n\n\n    async getAddress(coinType?: number): Promise<string> {\n        if (coinType == null) { coinType = 60; }\n\n        // If Ethereum, use the standard `addr(bytes32)`\n        if (coinType === 60) {\n            try {\n                // keccak256(\"addr(bytes32)\")\n                const transaction = {\n                    to: this.address,\n                    data: (\"0x3b3b57de\" + namehash(this.name).substring(2))\n                };\n                const hexBytes = await this.provider.call(transaction);\n\n                // No address\n                if (hexBytes === \"0x\" || hexBytes === HashZero) { return null; }\n\n                return this.provider.formatter.callAddress(hexBytes);\n            } catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n                throw error;\n            }\n        }\n\n        // keccak256(\"addr(bytes32,uint256\")\n        const hexBytes = await this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType));\n\n        // No address\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        // Compute the address\n        const address = this._getAddress(coinType, hexBytes);\n\n        if (address == null) {\n            logger.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${ coinType })`,\n                coinType: coinType,\n                data: hexBytes\n            });\n        }\n\n        return address;\n    }\n\n    async getAvatar(): Promise<null | Avatar> {\n        const linkage: Array<{ type: string, content: string }> = [ { type: \"name\", content: this.name } ];\n        try {\n            // test data for ricmoo.eth\n            //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n            const avatar = await this.getText(\"avatar\");\n            if (avatar == null) { return null; }\n\n            for (let i = 0; i < matchers.length; i++) {\n                const match = avatar.match(matchers[i]);\n                if (match == null) { continue; }\n\n                const scheme = match[1].toLowerCase();\n\n                switch (scheme) {\n                    case \"https\":\n                        linkage.push({ type: \"url\", content: avatar });\n                        return { linkage, url: avatar };\n\n                    case \"data\":\n                        linkage.push({ type: \"data\", content: avatar });\n                        return { linkage, url: avatar };\n\n                    case \"ipfs\":\n                        linkage.push({ type: \"ipfs\", content: avatar });\n                        return { linkage, url: getIpfsLink(avatar) };\n\n                    case \"erc721\":\n                    case \"erc1155\": {\n                        // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                        const selector = (scheme === \"erc721\") ? \"0xc87b56dd\": \"0x0e89341c\";\n                        linkage.push({ type: scheme, content: avatar });\n\n                        // The owner of this name\n                        const owner = (this._resolvedAddress || await this.getAddress());\n\n                        const comps = (match[2] || \"\").split(\"/\");\n                        if (comps.length !== 2) { return null; }\n\n                        const addr = await this.provider.formatter.address(comps[0]);\n                        const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);\n\n                        // Check that this account owns the token\n                        if (scheme === \"erc721\") {\n                            // ownerOf(uint256 tokenId)\n                            const tokenOwner = this.provider.formatter.callAddress(await this.provider.call({\n                                to: addr, data: hexConcat([ \"0x6352211e\", tokenId ])\n                            }));\n                            if (owner !== tokenOwner) { return null; }\n                            linkage.push({ type: \"owner\", content: tokenOwner });\n\n                        } else if (scheme === \"erc1155\") {\n                            // balanceOf(address owner, uint256 tokenId)\n                            const balance = BigNumber.from(await this.provider.call({\n                                to: addr, data: hexConcat([ \"0x00fdd58e\", hexZeroPad(owner, 32), tokenId ])\n                            }));\n                            if (balance.isZero()) { return null; }\n                            linkage.push({ type: \"balance\", content: balance.toString() });\n                        }\n\n                        // Call the token contract for the metadata URL\n                        const tx = {\n                            to: this.provider.formatter.address(comps[0]),\n                            data: hexConcat([ selector, tokenId ])\n                        };\n\n                        let metadataUrl = _parseString(await this.provider.call(tx))\n                        if (metadataUrl == null) { return null; }\n                        linkage.push({ type: \"metadata-url-base\", content: metadataUrl });\n\n                        // ERC-1155 allows a generic {id} in the URL\n                        if (scheme === \"erc1155\") {\n                            metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n                            linkage.push({ type: \"metadata-url-expanded\", content: metadataUrl });\n                        }\n\n                        // Transform IPFS metadata links\n                        if (metadataUrl.match(/^ipfs:/i)) {\n                            metadataUrl = getIpfsLink(metadataUrl);\n                        }\n\n                        linkage.push({ type: \"metadata-url\", content: metadataUrl });\n\n                        // Get the token metadata\n                        const metadata = await fetchJson(metadataUrl);\n                        if (!metadata) { return null; }\n                        linkage.push({ type: \"metadata\", content: JSON.stringify(metadata) });\n\n                        // Pull the image URL out\n                        let imageUrl = metadata.image;\n                        if (typeof(imageUrl) !== \"string\") { return null; }\n\n                        if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                            // Allow\n                        } else {\n                            // Transform IPFS link to gateway\n                            const ipfs = imageUrl.match(matcherIpfs);\n                            if (ipfs == null) { return null; }\n\n                            linkage.push({ type: \"url-ipfs\", content: imageUrl });\n                            imageUrl = getIpfsLink(imageUrl);\n                        }\n\n                        linkage.push({ type: \"url\", content: imageUrl });\n\n                        return { linkage, url: imageUrl };\n                    }\n                }\n            }\n        } catch (error) { }\n\n        return null;\n    }\n\n    async getContentHash(): Promise<string> {\n\n        // keccak256(\"contenthash()\")\n        const hexBytes = await this._fetchBytes(\"0xbc1c58d1\");\n\n        // No contenthash\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        // IPFS (CID: 1, Type: DAG-PB)\n        const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipfs) {\n            const length = parseInt(ipfs[3], 16);\n            if (ipfs[4].length === length * 2) {\n                return \"ipfs:/\\/\" + Base58.encode(\"0x\" + ipfs[1]);\n            }\n        }\n\n        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n        const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/)\n        if (swarm) {\n            if (swarm[1].length === (32 * 2)) {\n                return \"bzz:/\\/\" + swarm[1]\n            }\n        }\n\n        return logger.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"getContentHash()\",\n            data: hexBytes\n        });\n    }\n\n    async getText(key: string): Promise<string> {\n\n        // The key encoded as parameter to fetchBytes\n        let keyBytes = toUtf8Bytes(key);\n\n        // The nodehash consumes the first slot, so the string pointer targets\n        // offset 64, with the length at offset 64 and data starting at offset 96\n        keyBytes = concat([ bytes32ify(64), bytes32ify(keyBytes.length), keyBytes ]);\n\n        // Pad to word-size (32 bytes)\n        if ((keyBytes.length % 32) !== 0) {\n            keyBytes = concat([ keyBytes, hexZeroPad(\"0x\", 32 - (key.length % 32)) ])\n        }\n\n        const hexBytes = await this._fetchBytes(\"0x59d1d43c\", hexlify(keyBytes));\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        return toUtf8String(hexBytes);\n    }\n}\n\nlet defaultFormatter: Formatter = null;\n\nlet nextPollId = 1;\n\nexport class BaseProvider extends Provider implements EnsProvider {\n    _networkPromise: Promise<Network>;\n    _network: Network;\n\n    _events: Array<Event>;\n\n    formatter: Formatter;\n\n    // To help mitigate the eventually consistent nature of the blockchain\n    // we keep a mapping of events we emit. If we emit an event X, we expect\n    // that a user should be able to query for that event in the callback,\n    // if the node returns null, we stall the response until we get back a\n    // meaningful value, since we may be hitting a re-org, or a node that\n    // has not indexed the event yet.\n    // Events:\n    //   - t:{hash}    - Transaction hash\n    //   - b:{hash}    - BlockHash\n    //   - block       - The most recent emitted block\n    _emitted: { [ eventName: string ]: number | \"pending\" };\n\n    _pollingInterval: number;\n    _poller: NodeJS.Timer;\n    _bootstrapPoll: NodeJS.Timer;\n\n    _lastBlockNumber: number;\n\n    _fastBlockNumber: number;\n    _fastBlockNumberPromise: Promise<number>;\n    _fastQueryDate: number;\n\n    _maxInternalBlockNumber: number;\n    _internalBlockNumber: Promise<{ blockNumber: number, reqTime: number, respTime: number }>;\n\n    readonly anyNetwork: boolean;\n\n\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */\n\n    constructor(network: Networkish | Promise<Network>) {\n        logger.checkNew(new.target, Provider);\n\n        super();\n\n        // Events being listened to\n        this._events = [];\n\n        this._emitted = { block: -2 };\n\n        this.formatter = new.target.getFormatter();\n\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        defineReadOnly(this, \"anyNetwork\", (network === \"any\"));\n        if (this.anyNetwork) { network = this.detectNetwork(); }\n\n        if (network instanceof Promise) {\n            this._networkPromise = network;\n\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch((error) => { });\n\n            // Trigger initial network setting (async)\n            this._ready().catch((error) => { });\n\n        } else {\n            const knownNetwork = getStatic<(network: Networkish) => Network>(new.target, \"getNetwork\")(network);\n            if (knownNetwork) {\n                defineReadOnly(this, \"_network\", knownNetwork);\n                this.emit(\"network\", knownNetwork, null);\n\n            } else {\n                logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n\n        this._maxInternalBlockNumber = -1024;\n\n        this._lastBlockNumber = -2;\n\n        this._pollingInterval = 4000;\n\n        this._fastQueryDate = 0;\n    }\n\n    async _ready(): Promise<Network> {\n        if (this._network == null) {\n            let network: Network = null;\n            if (this._networkPromise) {\n                try {\n                    network = await this._networkPromise;\n                } catch (error) { }\n            }\n\n            // Try the Provider's network detection (this MUST throw if it cannot)\n            if (network == null) {\n                network = await this.detectNetwork();\n            }\n\n            // This should never happen; every Provider sub-class should have\n            // suggested a network by here (or have thrown).\n            if (!network) {\n                logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, { });\n            }\n\n            // Possible this call stacked so do not call defineReadOnly again\n            if (this._network == null) {\n                if (this.anyNetwork) {\n                    this._network = network;\n                } else {\n                    defineReadOnly(this, \"_network\", network);\n                }\n                this.emit(\"network\", network, null);\n            }\n        }\n\n        return this._network;\n    }\n\n    // This will always return the most recently established network.\n    // For \"any\", this can change (a \"network\" event is emitted before\n    // any change is reflected); otherwise this cannot change\n    get ready(): Promise<Network> {\n        return poll(() => {\n            return this._ready().then((network) => {\n                return network;\n            }, (error) => {\n                // If the network isn't running yet, we will wait\n                if (error.code === Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                    return undefined;\n                }\n                throw error;\n            });\n        });\n    }\n\n    // @TODO: Remove this and just create a singleton formatter\n    static getFormatter(): Formatter {\n        if (defaultFormatter == null) {\n            defaultFormatter = new Formatter();\n        }\n        return defaultFormatter;\n    }\n\n    // @TODO: Remove this and just use getNetwork\n    static getNetwork(network: Networkish): Network {\n        return getNetwork((network == null) ? \"homestead\": network);\n    }\n\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    async _getInternalBlockNumber(maxAge: number): Promise<number> {\n        await this._ready();\n\n        // Allowing stale data up to maxAge old\n        if (maxAge > 0) {\n\n            // While there are pending internal block requests...\n            while (this._internalBlockNumber) {\n\n                // ...\"remember\" which fetch we started with\n                const internalBlockNumber = this._internalBlockNumber;\n\n                try {\n                    // Check the result is not too stale\n                    const result = await internalBlockNumber;\n                    if ((getTime() - result.respTime) <= maxAge) {\n                        return result.blockNumber;\n                    }\n\n                    // Too old; fetch a new value\n                    break;\n\n                } catch(error) {\n\n                    // The fetch rejected; if we are the first to get the\n                    // rejection, drop through so we replace it with a new\n                    // fetch; all others blocked will then get that fetch\n                    // which won't match the one they \"remembered\" and loop\n                    if (this._internalBlockNumber === internalBlockNumber) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        const reqTime = getTime();\n\n        const checkInternalBlockNumber = resolveProperties({\n            blockNumber: this.perform(\"getBlockNumber\", { }),\n            networkError: this.getNetwork().then((network) => (null), (error) => (error))\n        }).then(({ blockNumber, networkError }) => {\n            if (networkError) {\n                // Unremember this bad internal block number\n                if (this._internalBlockNumber === checkInternalBlockNumber) {\n                    this._internalBlockNumber = null;\n                }\n                throw networkError;\n            }\n\n            const respTime = getTime();\n\n            blockNumber = BigNumber.from(blockNumber).toNumber();\n            if (blockNumber < this._maxInternalBlockNumber) { blockNumber = this._maxInternalBlockNumber; }\n\n            this._maxInternalBlockNumber = blockNumber;\n            this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n            return { blockNumber, reqTime, respTime };\n        });\n\n        this._internalBlockNumber = checkInternalBlockNumber;\n\n        // Swallow unhandled exceptions; if needed they are handled else where\n        checkInternalBlockNumber.catch((error) => {\n            // Don't null the dead (rejected) fetch, if it has already been updated\n            if (this._internalBlockNumber === checkInternalBlockNumber) {\n                this._internalBlockNumber = null;\n            }\n        });\n\n        return (await checkInternalBlockNumber).blockNumber;\n    }\n\n    async poll(): Promise<void> {\n        const pollId = nextPollId++;\n\n        // Track all running promises, so we can trigger a post-poll once they are complete\n        const runners: Array<Promise<void>> = [];\n\n        let blockNumber: number = null;\n        try {\n            blockNumber = await this._getInternalBlockNumber(100 + this.pollingInterval / 2);\n        } catch (error) {\n            this.emit(\"error\", error);\n            return;\n        }\n        this._setFastBlockNumber(blockNumber);\n\n        // Emit a poll event after we have the latest (fast) block number\n        this.emit(\"poll\", pollId, blockNumber);\n\n        // If the block has not changed, meh.\n        if (blockNumber === this._lastBlockNumber) {\n            this.emit(\"didPoll\", pollId);\n            return;\n        }\n\n        // First polling cycle, trigger a \"block\" events\n        if (this._emitted.block === -2) {\n            this._emitted.block = blockNumber - 1;\n        }\n\n        if (Math.abs((<number>(this._emitted.block)) - blockNumber) > 1000) {\n            logger.warn(`network block skew detected; skipping block events (emitted=${ this._emitted.block } blockNumber${ blockNumber })`);\n            this.emit(\"error\", logger.makeError(\"network block skew detected\", Logger.errors.NETWORK_ERROR, {\n                blockNumber: blockNumber,\n                event: \"blockSkew\",\n                previousBlockNumber: this._emitted.block\n            }));\n            this.emit(\"block\", blockNumber);\n\n        } else {\n            // Notify all listener for each block that has passed\n            for (let i = (<number>this._emitted.block) + 1; i <= blockNumber; i++) {\n                this.emit(\"block\", i);\n            }\n        }\n\n        // The emitted block was updated, check for obsolete events\n        if ((<number>this._emitted.block) !== blockNumber) {\n            this._emitted.block = blockNumber;\n\n            Object.keys(this._emitted).forEach((key) => {\n                // The block event does not expire\n                if (key === \"block\") { return; }\n\n                // The block we were at when we emitted this event\n                const eventBlockNumber = this._emitted[key];\n\n                // We cannot garbage collect pending transactions or blocks here\n                // They should be garbage collected by the Provider when setting\n                // \"pending\" events\n                if (eventBlockNumber === \"pending\") { return; }\n\n                // Evict any transaction hashes or block hashes over 12 blocks\n                // old, since they should not return null anyways\n                if (blockNumber - eventBlockNumber > 12) {\n                    delete this._emitted[key];\n                }\n            });\n        }\n\n        // First polling cycle\n        if (this._lastBlockNumber === -2) {\n            this._lastBlockNumber = blockNumber - 1;\n        }\n\n        // Find all transaction hashes we are waiting on\n        this._events.forEach((event) => {\n            switch (event.type) {\n                case \"tx\": {\n                    const hash = event.hash;\n                    let runner = this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt || receipt.blockNumber == null) { return null; }\n                        this._emitted[\"t:\" + hash] = receipt.blockNumber;\n                        this.emit(hash, receipt);\n                        return null;\n                    }).catch((error: Error) => { this.emit(\"error\", error); });\n\n                    runners.push(runner);\n\n                    break;\n                }\n\n                case \"filter\": {\n                    const filter = event.filter;\n                    filter.fromBlock = this._lastBlockNumber + 1;\n                    filter.toBlock = blockNumber;\n\n                    const runner = this.getLogs(filter).then((logs) => {\n                        if (logs.length === 0) { return; }\n                        logs.forEach((log: Log) => {\n                            this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                            this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n                            this.emit(filter, log);\n                        });\n                    }).catch((error: Error) => { this.emit(\"error\", error); });\n                    runners.push(runner);\n\n                    break;\n                }\n            }\n        });\n\n        this._lastBlockNumber = blockNumber;\n\n        // Once all events for this loop have been processed, emit \"didPoll\"\n        Promise.all(runners).then(() => {\n            this.emit(\"didPoll\", pollId);\n        }).catch((error) => { this.emit(\"error\", error); });\n\n        return;\n    }\n\n    // Deprecated; do not use this\n    resetEventsBlock(blockNumber: number): void {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) { this.poll(); }\n    }\n\n    get network(): Network {\n        return this._network;\n    }\n\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    async detectNetwork(): Promise<Network> {\n        return logger.throwError(\"provider does not support network detection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"provider.detectNetwork\"\n        });\n    }\n\n    async getNetwork(): Promise<Network> {\n        const network = await this._ready();\n\n        // Make sure we are still connected to the same network; this is\n        // only an external call for backends which can have the underlying\n        // network change spontaneously\n        const currentNetwork = await this.detectNetwork();\n        if (network.chainId !== currentNetwork.chainId) {\n\n            // We are allowing network changes, things can get complex fast;\n            // make sure you know what you are doing if you use \"any\"\n            if (this.anyNetwork) {\n                this._network = currentNetwork;\n\n                // Reset all internal block number guards and caches\n                this._lastBlockNumber = -2;\n                this._fastBlockNumber = null;\n                this._fastBlockNumberPromise = null;\n                this._fastQueryDate = 0;\n                this._emitted.block = -2;\n                this._maxInternalBlockNumber = -1024;\n                this._internalBlockNumber = null;\n\n                // The \"network\" event MUST happen before this method resolves\n                // so any events have a chance to unregister, so we stall an\n                // additional event loop before returning from /this/ call\n                this.emit(\"network\", currentNetwork, network);\n                await stall(0);\n\n                return this._network;\n            }\n\n            const error = logger.makeError(\"underlying network changed\", Logger.errors.NETWORK_ERROR, {\n                event: \"changed\",\n                network: network,\n                detectedNetwork: currentNetwork\n            });\n\n            this.emit(\"error\", error);\n            throw error;\n        }\n\n        return network;\n    }\n\n    get blockNumber(): number {\n        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {\n            this._setFastBlockNumber(blockNumber);\n        }, (error) => { });\n\n        return (this._fastBlockNumber != null) ? this._fastBlockNumber: -1;\n    }\n\n    get polling(): boolean {\n        return (this._poller != null);\n    }\n\n    set polling(value: boolean) {\n        if (value && !this._poller) {\n            this._poller = setInterval(() => { this.poll(); }, this.pollingInterval);\n\n            if (!this._bootstrapPoll) {\n                this._bootstrapPoll = setTimeout(() => {\n                    this.poll();\n\n                    // We block additional polls until the polling interval\n                    // is done, to prevent overwhelming the poll function\n                    this._bootstrapPoll = setTimeout(() => {\n                        // If polling was disabled, something may require a poke\n                        // since starting the bootstrap poll and it was disabled\n                        if (!this._poller) { this.poll(); }\n\n                        // Clear out the bootstrap so we can do another\n                        this._bootstrapPoll = null;\n                    }, this.pollingInterval);\n                }, 0);\n            }\n\n        } else if (!value && this._poller) {\n            clearInterval(this._poller);\n            this._poller = null;\n        }\n    }\n\n    get pollingInterval(): number {\n        return this._pollingInterval;\n    }\n\n    set pollingInterval(value: number) {\n        if (typeof(value) !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n            throw new Error(\"invalid polling interval\");\n        }\n\n        this._pollingInterval = value;\n\n        if (this._poller) {\n            clearInterval(this._poller);\n            this._poller = setInterval(() => { this.poll(); }, this._pollingInterval);\n        }\n    }\n\n    _getFastBlockNumber(): Promise<number> {\n        const now = getTime();\n\n        // Stale block number, request a newer value\n        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {\n                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n                    this._fastBlockNumber = blockNumber;\n                }\n                return this._fastBlockNumber;\n            });\n        }\n\n        return this._fastBlockNumberPromise;\n    }\n\n    _setFastBlockNumber(blockNumber: number): void {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) { return; }\n\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    }\n\n    async waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt> {\n        return this._waitForTransaction(transactionHash, (confirmations == null) ? 1: confirmations, timeout || 0, null);\n    }\n\n    async _waitForTransaction(transactionHash: string, confirmations: number, timeout: number, replaceable: { data: string, from: string, nonce: number, to: string, value: BigNumber, startBlock: number }): Promise<TransactionReceipt> {\n        const receipt = await this.getTransactionReceipt(transactionHash);\n\n        // Receipt is already good\n        if ((receipt ? receipt.confirmations: 0) >= confirmations) { return receipt; }\n\n        // Poll until the receipt is good...\n        return new Promise((resolve, reject) => {\n            const cancelFuncs: Array<() => void> = [];\n\n            let done = false;\n            const alreadyDone = function() {\n                if (done) { return true; }\n                done = true;\n                cancelFuncs.forEach((func) => { func(); });\n                return false;\n            };\n\n            const minedHandler = (receipt: TransactionReceipt) => {\n                if (receipt.confirmations < confirmations) { return; }\n                if (alreadyDone()) { return; }\n                resolve(receipt);\n            }\n            this.on(transactionHash, minedHandler);\n            cancelFuncs.push(() => { this.removeListener(transactionHash, minedHandler); });\n\n            if (replaceable) {\n                let lastBlockNumber = replaceable.startBlock;\n                let scannedBlock: number = null;\n                const replaceHandler = async (blockNumber: number) => {\n                    if (done) { return; }\n\n                    // Wait 1 second; this is only used in the case of a fault, so\n                    // we will trade off a little bit of latency for more consistent\n                    // results and fewer JSON-RPC calls\n                    await stall(1000);\n\n                    this.getTransactionCount(replaceable.from).then(async (nonce) => {\n                        if (done) { return; }\n\n                        if (nonce <= replaceable.nonce) {\n                            lastBlockNumber = blockNumber;\n\n                        } else {\n                            // First check if the transaction was mined\n                            {\n                                const mined = await this.getTransaction(transactionHash);\n                                if (mined && mined.blockNumber != null) { return; }\n                            }\n\n                            // First time scanning. We start a little earlier for some\n                            // wiggle room here to handle the eventually consistent nature\n                            // of blockchain (e.g. the getTransactionCount was for a\n                            // different block)\n                            if (scannedBlock == null) {\n                                scannedBlock = lastBlockNumber - 3;\n                                if (scannedBlock < replaceable.startBlock) {\n                                    scannedBlock = replaceable.startBlock;\n                                }\n                            }\n\n                            while (scannedBlock <= blockNumber) {\n                                if (done) { return; }\n\n                                const block = await this.getBlockWithTransactions(scannedBlock);\n                                for (let ti = 0; ti < block.transactions.length; ti++) {\n                                    const tx = block.transactions[ti];\n\n                                    // Successfully mined!\n                                    if (tx.hash === transactionHash) { return; }\n\n                                    // Matches our transaction from and nonce; its a replacement\n                                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {\n                                        if (done) { return; }\n\n                                        // Get the receipt of the replacement\n                                        const receipt = await this.waitForTransaction(tx.hash, confirmations);\n\n                                        // Already resolved or rejected (prolly a timeout)\n                                        if (alreadyDone()) { return; }\n\n                                        // The reason we were replaced\n                                        let reason = \"replaced\";\n                                        if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                            reason = \"repriced\";\n                                        } else  if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                            reason = \"cancelled\"\n                                        }\n\n                                        // Explain why we were replaced\n                                        reject(logger.makeError(\"transaction was replaced\", Logger.errors.TRANSACTION_REPLACED, {\n                                            cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                                            reason,\n                                            replacement: this._wrapTransaction(tx),\n                                            hash: transactionHash,\n                                            receipt\n                                        }));\n\n                                        return;\n                                    }\n                                }\n                                scannedBlock++;\n                            }\n                        }\n\n                        if (done) { return; }\n                        this.once(\"block\", replaceHandler);\n\n                    }, (error) => {\n                        if (done) { return; }\n                        this.once(\"block\", replaceHandler);\n                    });\n                };\n\n                if (done) { return; }\n                this.once(\"block\", replaceHandler);\n\n                cancelFuncs.push(() => {\n                    this.removeListener(\"block\", replaceHandler);\n                });\n            }\n\n            if (typeof(timeout) === \"number\" && timeout > 0) {\n                const timer = setTimeout(() => {\n                    if (alreadyDone()) { return; }\n                    reject(logger.makeError(\"timeout exceeded\", Logger.errors.TIMEOUT, { timeout: timeout }));\n                }, timeout);\n                if (timer.unref) { timer.unref(); }\n\n                cancelFuncs.push(() => { clearTimeout(timer); });\n            }\n        });\n    }\n\n    async getBlockNumber(): Promise<number> {\n        return this._getInternalBlockNumber(0);\n    }\n\n    async getGasPrice(): Promise<BigNumber> {\n        await this.getNetwork();\n\n        const result = await this.perform(\"getGasPrice\", { });\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getGasPrice\",\n                result, error\n            });\n        }\n    }\n\n    async getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getBalance\", params);\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getBalance\",\n                params, result, error\n            });\n        }\n    }\n\n    async getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getTransactionCount\", params);\n        try {\n            return BigNumber.from(result).toNumber();\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getTransactionCount\",\n                params, result, error\n            });\n        }\n    }\n\n    async getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getCode\", params);\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getCode\",\n                params, result, error\n            });\n        }\n    }\n\n    async getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag),\n            position: Promise.resolve(position).then((p) => hexValue(p))\n        });\n        const result = await this.perform(\"getStorageAt\", params);\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getStorageAt\",\n                params, result, error\n            });\n        }\n    }\n\n    // This should be called by any subclass wrapping a TransactionResponse\n    _wrapTransaction(tx: Transaction, hash?: string, startBlock?: number): TransactionResponse {\n        if (hash != null && hexDataLength(hash) !== 32) { throw new Error(\"invalid response - sendTransaction\"); }\n\n        const result = <TransactionResponse>tx;\n\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });\n        }\n\n        result.wait = async (confirms?: number, timeout?: number) => {\n            if (confirms == null) { confirms = 1; }\n            if (timeout == null) { timeout = 0; }\n\n            // Get the details to detect replacement\n            let replacement = undefined;\n            if (confirms !== 0 && startBlock != null) {\n                replacement = {\n                    data: tx.data,\n                    from: tx.from,\n                    nonce: tx.nonce,\n                    to: tx.to,\n                    value: tx.value,\n                    startBlock\n                };\n            }\n\n            const receipt = await this._waitForTransaction(tx.hash, confirms, timeout, replacement);\n            if (receipt == null && confirms === 0) { return null; }\n\n            // No longer pending, allow the polling loop to garbage collect this\n            this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n\n            if (receipt.status === 0) {\n                logger.throwError(\"transaction failed\", Logger.errors.CALL_EXCEPTION, {\n                    transactionHash: tx.hash,\n                    transaction: tx,\n                    receipt: receipt\n                });\n            }\n            return receipt;\n        };\n\n        return result;\n    }\n\n    async sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse> {\n        await this.getNetwork();\n        const hexTx = await Promise.resolve(signedTransaction).then(t => hexlify(t));\n        const tx = this.formatter.transaction(signedTransaction);\n        if (tx.confirmations == null) { tx.confirmations = 0; }\n        const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n        try {\n            const hash = await this.perform(\"sendTransaction\", { signedTransaction: hexTx });\n            return this._wrapTransaction(tx, hash, blockNumber);\n        } catch (error) {\n            (<any>error).transaction = tx;\n            (<any>error).transactionHash = tx.hash;\n            throw error;\n        }\n    }\n\n    async _getTransactionRequest(transaction: Deferrable<TransactionRequest>): Promise<Transaction> {\n        const values: any = await transaction;\n\n        const tx: any = { };\n\n        [\"from\", \"to\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? this._getAddress(v): null))\n        });\n\n        [\"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"value\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? BigNumber.from(v): null));\n        });\n\n        [\"type\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => ((v != null) ? v: null));\n        });\n\n        if (values.accessList) {\n            tx.accessList = this.formatter.accessList(values.accessList);\n        }\n\n        [\"data\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? hexlify(v): null));\n        });\n\n        return this.formatter.transactionRequest(await resolveProperties(tx));\n    }\n\n    async _getFilter(filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>): Promise<Filter | FilterByBlockHash> {\n        filter = await filter;\n\n        const result: any = { };\n\n        if (filter.address != null) {\n            result.address = this._getAddress(filter.address);\n        }\n\n        [\"blockHash\", \"topics\"].forEach((key) => {\n            if ((<any>filter)[key] == null) { return; }\n            result[key] = (<any>filter)[key];\n        });\n\n        [\"fromBlock\", \"toBlock\"].forEach((key) => {\n            if ((<any>filter)[key] == null) { return; }\n            result[key] = this._getBlockTag((<any>filter)[key]);\n        });\n\n        return this.formatter.filter(await resolveProperties(result));\n    }\n\n    async call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            transaction: this._getTransactionRequest(transaction),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"call\", params);\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"call\",\n                params, result, error\n            });\n        }\n    }\n\n    async estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            transaction: this._getTransactionRequest(transaction)\n        });\n\n        const result = await this.perform(\"estimateGas\", params);\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"estimateGas\",\n                params, result, error\n            });\n        }\n    }\n\n    async _getAddress(addressOrName: string | Promise<string>): Promise<string> {\n        addressOrName = await addressOrName;\n        if (typeof(addressOrName) !== \"string\") {\n            logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n        }\n\n        const address = await this.resolveName(addressOrName);\n        if (address == null) {\n            logger.throwError(\"ENS name not configured\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `resolveName(${ JSON.stringify(addressOrName) })`\n            });\n        }\n        return address;\n    }\n\n    async _getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>, includeTransactions?: boolean): Promise<Block | BlockWithTransactions> {\n        await this.getNetwork();\n\n        blockHashOrBlockTag = await blockHashOrBlockTag;\n\n        // If blockTag is a number (not \"latest\", etc), this is the block number\n        let blockNumber = -128;\n\n        const params: { [key: string]: any } = {\n            includeTransactions: !!includeTransactions\n        };\n\n        if (isHexString(blockHashOrBlockTag, 32)) {\n            params.blockHash = blockHashOrBlockTag;\n        } else {\n            try {\n                params.blockTag = await this._getBlockTag(blockHashOrBlockTag);\n                if (isHexString(params.blockTag)) {\n                    blockNumber = parseInt(params.blockTag.substring(2), 16);\n                }\n            } catch (error) {\n                logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n            }\n        }\n\n        return poll(async () => {\n            const block = await this.perform(\"getBlock\", params);\n\n            // Block was not found\n            if (block == null) {\n\n                // For blockhashes, if we didn't say it existed, that blockhash may\n                // not exist. If we did see it though, perhaps from a log, we know\n                // it exists, and this node is just not caught up yet.\n                if (params.blockHash != null) {\n                    if (this._emitted[\"b:\" + params.blockHash] == null) { return null; }\n                }\n\n                // For block tags, if we are asking for a future block, we return null\n                if (params.blockTag != null) {\n                    if (blockNumber > this._emitted.block) { return null; }\n                }\n\n                // Retry on the next block\n                return undefined;\n            }\n\n            // Add transactions\n            if (includeTransactions) {\n                let blockNumber: number = null;\n                for (let i = 0; i < block.transactions.length; i++) {\n                    const tx = block.transactions[i];\n                    if (tx.blockNumber == null) {\n                        tx.confirmations = 0;\n\n                    } else if (tx.confirmations == null) {\n                        if (blockNumber == null) {\n                            blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                        }\n\n                        // Add the confirmations using the fast block number (pessimistic)\n                        let confirmations = (blockNumber - tx.blockNumber) + 1;\n                        if (confirmations <= 0) { confirmations = 1; }\n                        tx.confirmations = confirmations;\n                    }\n                }\n\n                const blockWithTxs: any = this.formatter.blockWithTransactions(block);\n                blockWithTxs.transactions = blockWithTxs.transactions.map((tx: TransactionResponse) => this._wrapTransaction(tx));\n                return blockWithTxs;\n            }\n\n            return this.formatter.block(block);\n\n        }, { oncePoll: this });\n    }\n\n    getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block> {\n        return <Promise<Block>>(this._getBlock(blockHashOrBlockTag, false));\n    }\n\n    getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<BlockWithTransactions> {\n        return <Promise<BlockWithTransactions>>(this._getBlock(blockHashOrBlockTag, true));\n    }\n\n    async getTransaction(transactionHash: string | Promise<string>): Promise<TransactionResponse> {\n        await this.getNetwork();\n        transactionHash = await transactionHash;\n\n        const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n\n        return poll(async () => {\n            const result = await this.perform(\"getTransaction\", params);\n\n            if (result == null) {\n                if (this._emitted[\"t:\" + transactionHash] == null) {\n                    return null;\n                }\n                return undefined;\n            }\n\n            const tx = this.formatter.transactionResponse(result);\n\n            if (tx.blockNumber == null) {\n                tx.confirmations = 0;\n\n            } else if (tx.confirmations == null) {\n                const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n\n                // Add the confirmations using the fast block number (pessimistic)\n                let confirmations = (blockNumber - tx.blockNumber) + 1;\n                if (confirmations <= 0) { confirmations = 1; }\n                tx.confirmations = confirmations;\n            }\n\n            return this._wrapTransaction(tx);\n        }, { oncePoll: this });\n    }\n\n    async getTransactionReceipt(transactionHash: string | Promise<string>): Promise<TransactionReceipt> {\n        await this.getNetwork();\n\n        transactionHash = await transactionHash;\n\n        const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n\n        return poll(async () => {\n            const result = await this.perform(\"getTransactionReceipt\", params);\n\n            if (result == null) {\n                if (this._emitted[\"t:\" + transactionHash] == null) {\n                    return null;\n                }\n                return undefined;\n            }\n\n            // \"geth-etc\" returns receipts before they are ready\n            if (result.blockHash == null) { return undefined; }\n\n            const receipt = this.formatter.receipt(result);\n\n            if (receipt.blockNumber == null) {\n                receipt.confirmations = 0;\n\n            } else if (receipt.confirmations == null) {\n                const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n\n                // Add the confirmations using the fast block number (pessimistic)\n                let confirmations = (blockNumber - receipt.blockNumber) + 1;\n                if (confirmations <= 0) { confirmations = 1; }\n                receipt.confirmations = confirmations;\n            }\n\n            return receipt;\n        }, { oncePoll: this });\n    }\n\n    async getLogs(filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>): Promise<Array<Log>> {\n        await this.getNetwork();\n        const params = await resolveProperties({ filter: this._getFilter(filter) });\n        const logs: Array<Log> = await this.perform(\"getLogs\", params);\n        logs.forEach((log) => {\n            if (log.removed == null) { log.removed = false; }\n        });\n        return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n    }\n\n    async getEtherPrice(): Promise<number> {\n        await this.getNetwork();\n        return this.perform(\"getEtherPrice\", { });\n    }\n\n    async _getBlockTag(blockTag: BlockTag | Promise<BlockTag>): Promise<BlockTag> {\n        blockTag = await blockTag;\n\n        if (typeof(blockTag) === \"number\" && blockTag < 0) {\n            if (blockTag % 1) {\n                logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n            }\n\n            let blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n            blockNumber += blockTag;\n            if (blockNumber < 0) { blockNumber = 0; }\n            return this.formatter.blockTag(blockNumber)\n        }\n\n        return this.formatter.blockTag(blockTag);\n    }\n\n\n    async getResolver(name: string): Promise<null | Resolver> {\n        try {\n            const address = await this._getResolver(name);\n            if (address == null) { return null; }\n            return new Resolver(this, address, name);\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n            throw error;\n        }\n    }\n\n    async _getResolver(name: string): Promise<string> {\n        // Get the resolver from the blockchain\n        const network = await this.getNetwork();\n\n        // No ENS...\n        if (!network.ensAddress) {\n            logger.throwError(\n                \"network does not support ENS\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { operation: \"ENS\", network: network.name }\n            );\n        }\n\n        // keccak256(\"resolver(bytes32)\")\n        const transaction = {\n            to: network.ensAddress,\n            data: (\"0x0178b8bf\" + namehash(name).substring(2))\n        };\n\n        try {\n            return this.formatter.callAddress(await this.call(transaction));\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n            throw error;\n        }\n    }\n\n    async resolveName(name: string | Promise<string>): Promise<null | string> {\n        name = await name;\n\n        // If it is already an address, nothing to resolve\n        try {\n            return Promise.resolve(this.formatter.address(name));\n        } catch (error) {\n            // If is is a hexstring, the address is bad (See #694)\n            if (isHexString(name)) { throw error; }\n        }\n\n        if (typeof(name) !== \"string\") {\n            logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n        }\n\n        // Get the addr from the resovler\n        const resolver = await this.getResolver(name);\n        if (!resolver) { return null; }\n\n        return await resolver.getAddress();\n    }\n\n    async lookupAddress(address: string | Promise<string>): Promise<null | string> {\n        address = await address;\n        address = this.formatter.address(address);\n\n        const reverseName = address.substring(2).toLowerCase() + \".addr.reverse\";\n\n        const resolverAddress = await this._getResolver(reverseName);\n        if (!resolverAddress) { return null; }\n\n        // keccak(\"name(bytes32)\")\n        let bytes = arrayify(await this.call({\n            to: resolverAddress,\n            data: (\"0x691f3431\" + namehash(reverseName).substring(2))\n        }));\n\n        // Strip off the dynamic string pointer (0x20)\n        if (bytes.length < 32 || !BigNumber.from(bytes.slice(0, 32)).eq(32)) { return null; }\n        bytes = bytes.slice(32);\n\n        // Not a length-prefixed string\n        if (bytes.length < 32) { return null; }\n\n        // Get the length of the string (from the length-prefix)\n        const length = BigNumber.from(bytes.slice(0, 32)).toNumber();\n        bytes = bytes.slice(32);\n\n        // Length longer than available data\n        if (length > bytes.length) { return null; }\n\n        const name = toUtf8String(bytes.slice(0, length));\n\n        // Make sure the reverse record matches the foward record\n        const addr = await this.resolveName(name);\n        if (addr != address) { return null; }\n\n        return name;\n    }\n\n    async getAvatar(nameOrAddress: string): Promise<null | string> {\n        let resolver: Resolver = null;\n        if (isHexString(nameOrAddress)) {\n            // Address; reverse lookup\n            const address = this.formatter.address(nameOrAddress);\n\n            const reverseName = address.substring(2).toLowerCase() + \".addr.reverse\";\n\n            const resolverAddress = await this._getResolver(reverseName);\n            if (!resolverAddress) { return null; }\n\n            resolver = new Resolver(this, resolverAddress, \"_\", address);\n\n        } else {\n            // ENS name; forward lookup\n            resolver = await this.getResolver(nameOrAddress);\n            if (!resolver) { return null; }\n        }\n\n        const avatar = await resolver.getAvatar();\n        if (avatar == null) { return null; }\n\n        return avatar.url;\n    }\n\n    perform(method: string, params: any): Promise<any> {\n        return logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n    }\n\n    _startEvent(event: Event): void {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n\n    _stopEvent(event: Event): void {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n\n    _addEventListener(eventName: EventType, listener: Listener, once: boolean): this {\n        const event = new Event(getEventTag(eventName), listener, once)\n        this._events.push(event);\n        this._startEvent(event);\n\n        return this;\n    }\n\n    on(eventName: EventType, listener: Listener): this {\n        return this._addEventListener(eventName, listener, false);\n    }\n\n    once(eventName: EventType, listener: Listener): this {\n        return this._addEventListener(eventName, listener, true);\n    }\n\n\n    emit(eventName: EventType, ...args: Array<any>): boolean {\n        let result = false;\n\n        let stopped: Array<Event> = [ ];\n\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag) { return true; }\n\n            setTimeout(() => {\n                event.listener.apply(this, args);\n            }, 0);\n\n            result = true;\n\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n\n            return true;\n        });\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return result;\n    }\n\n    listenerCount(eventName?: EventType): number {\n        if (!eventName) { return this._events.length; }\n\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event) => {\n            return (event.tag === eventTag);\n        }).length;\n    }\n\n    listeners(eventName?: EventType): Array<Listener> {\n        if (eventName == null) {\n            return this._events.map((event) => event.listener);\n        }\n\n        let eventTag = getEventTag(eventName);\n        return this._events\n            .filter((event) => (event.tag === eventTag))\n            .map((event) => event.listener);\n    }\n\n    off(eventName: EventType, listener?: Listener): this {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n\n        const stopped: Array<Event> = [ ];\n\n        let found = false;\n\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag || event.listener != listener) { return true; }\n            if (found) { return true; }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return this;\n    }\n\n    removeAllListeners(eventName?: EventType): this {\n        let stopped: Array<Event> = [ ];\n        if (eventName == null) {\n            stopped = this._events;\n\n            this._events = [ ];\n        } else {\n            const eventTag = getEventTag(eventName);\n            this._events = this._events.filter((event) => {\n                if (event.tag !== eventTag) { return true; }\n                stopped.push(event);\n                return false;\n            });\n        }\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return this;\n    }\n}\n","export const HashZero = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n\n","import { TypedDataDomain, TypedDataField } from \"@ethersproject/abstract-signer\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, hexConcat, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { id } from \"./id\";\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\n\nconst NegativeOne: BigNumber = BigNumber.from(-1);\nconst Zero: BigNumber = BigNumber.from(0);\nconst One: BigNumber = BigNumber.from(1);\nconst MaxUint256: BigNumber = BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\nfunction hexPadRight(value: BytesLike) {\n    const bytes = arrayify(value);\n    const padOffset = bytes.length % 32\n    if (padOffset) {\n        return hexConcat([ bytes, padding.slice(padOffset) ]);\n    }\n    return hexlify(bytes);\n}\n\nconst hexTrue = hexZeroPad(One.toHexString(), 32);\nconst hexFalse = hexZeroPad(Zero.toHexString(), 32);\n\nconst domainFieldTypes: Record<string, string> = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\n\nconst domainFieldNames: Array<string> = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\n\nfunction checkString(key: string): (value: any) => string {\n    return function (value: any){\n        if (typeof(value) !== \"string\") {\n            logger.throwArgumentError(`invalid domain value for ${ JSON.stringify(key) }`, `domain.${ key }`, value);\n        }\n        return value;\n    }\n}\n\nconst domainChecks: Record<string, (value: any) => any> = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function(value: any) {\n        try {\n            return BigNumber.from(value).toString()\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value for \"chainId\"`, \"domain.chainId\", value);\n    },\n    verifyingContract: function(value: any) {\n        try {\n            return getAddress(value).toLowerCase();\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function(value: any) {\n        try {\n            const bytes = arrayify(value);\n            if (bytes.length !== 32) { throw new Error(\"bad length\"); }\n            return hexlify(bytes);\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"salt\"`, \"domain.salt\", value);\n    }\n}\n\nfunction getBaseEncoder(type: string): (value: any) => string {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n\n            const width = parseInt(match[2] || \"256\");\n            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {\n                logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n            }\n\n            const boundsUpper = MaxUint256.mask(signed ? (width - 1): width);\n            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne): Zero;\n\n            return function(value: BigNumberish) {\n                const v = BigNumber.from(value);\n\n                if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n                    logger.throwArgumentError(`value out-of-bounds for ${ type }`, \"value\", value);\n                }\n\n                return hexZeroPad(v.toTwos(256).toHexString(), 32);\n            };\n        }\n    }\n\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            if (width === 0 || width > 32 || match[1] !== String(width)) {\n                logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n            }\n\n            return function(value: BytesLike) {\n                const bytes = arrayify(value);\n                if (bytes.length !== width) {\n                    logger.throwArgumentError(`invalid length for ${ type }`, \"value\", value);\n                }\n                return hexPadRight(value);\n            };\n        }\n    }\n\n    switch (type) {\n        case \"address\": return function(value: string) {\n            return hexZeroPad(getAddress(value), 32);\n        };\n        case \"bool\": return function(value: boolean) {\n            return ((!value) ? hexFalse: hexTrue);\n        };\n        case \"bytes\": return function(value: BytesLike) {\n            return keccak256(value);\n        };\n        case \"string\": return function(value: string) {\n            return id(value);\n        };\n    }\n\n    return null;\n}\n\nfunction encodeType(name: string, fields: Array<TypedDataField>): string {\n    return `${ name }(${ fields.map(({ name, type }) => (type + \" \" + name)).join(\",\") })`;\n}\n\nexport class TypedDataEncoder {\n    readonly primaryType: string;\n    readonly types: Record<string, Array<TypedDataField>>;\n\n    readonly _encoderCache: Record<string, (value: any) => string>;\n    readonly _types: Record<string, string>;\n\n    constructor(types: Record<string, Array<TypedDataField>>) {\n        defineReadOnly(this, \"types\", Object.freeze(deepCopy(types)));\n\n        defineReadOnly(this, \"_encoderCache\", { });\n        defineReadOnly(this, \"_types\", { });\n\n        // Link struct types to their direct child structs\n        const links: Record<string, Record<string, boolean>> = { };\n\n        // Link structs to structs which contain them as a child\n        const parents: Record<string, Array<string>> = { };\n\n        // Link all subtypes within a given struct\n        const subtypes: Record<string, Record<string, boolean>> = { };\n\n        Object.keys(types).forEach((type) => {\n            links[type] = { };\n            parents[type] = [ ];\n            subtypes[type] = { }\n        });\n\n        for (const name in types) {\n\n            const uniqueNames: Record<string, boolean> = { };\n\n            types[name].forEach((field) => {\n\n                // Check each field has a unique name\n                if (uniqueNames[field.name]) {\n                    logger.throwArgumentError(`duplicate variable name ${ JSON.stringify(field.name) } in ${ JSON.stringify(name) }`, \"types\", types);\n                }\n                uniqueNames[field.name] = true;\n\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n                if (baseType === name) {\n                    logger.throwArgumentError(`circular type reference to ${ JSON.stringify(baseType) }`, \"types\", types);\n                }\n\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) { return ;}\n\n                if (!parents[baseType]) {\n                    logger.throwArgumentError(`unknown type ${ JSON.stringify(baseType) }`, \"types\", types);\n                }\n\n                // Add linkage\n                parents[baseType].push(name);\n                links[name][baseType] = true;\n            });\n        }\n\n        // Deduce the primary type\n        const primaryTypes = Object.keys(parents).filter((n) => (parents[n].length === 0));\n\n        if (primaryTypes.length === 0) {\n            logger.throwArgumentError(\"missing primary type\", \"types\", types);\n        } else if (primaryTypes.length > 1) {\n            logger.throwArgumentError(`ambiguous primary types or unused types: ${ primaryTypes.map((t) => (JSON.stringify(t))).join(\", \") }`, \"types\", types);\n        }\n\n        defineReadOnly(this, \"primaryType\", primaryTypes[0]);\n\n        // Check for circular type references\n        function checkCircular(type: string, found: Record<string, boolean>) {\n            if (found[type]) {\n                logger.throwArgumentError(`circular type reference to ${ JSON.stringify(type) }`, \"types\", types);\n            }\n\n            found[type] = true;\n\n            Object.keys(links[type]).forEach((child) => {\n                if (!parents[child]) { return; }\n\n                // Recursively check children\n                checkCircular(child, found);\n\n                // Mark all ancestors as having this decendant\n                Object.keys(found).forEach((subtype) => {\n                    subtypes[subtype][child] = true;\n                });\n            });\n\n            delete found[type];\n        }\n        checkCircular(this.primaryType, { });\n\n        // Compute each fully describe type\n        for (const name in subtypes) {\n            const st = Object.keys(subtypes[name]);\n            st.sort();\n            this._types[name] = encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\");\n        }\n    }\n\n    getEncoder(type: string): (value: any) => string {\n        let encoder = this._encoderCache[type];\n        if (!encoder) {\n            encoder = this._encoderCache[type] = this._getEncoder(type);\n        }\n        return encoder;\n    }\n\n    _getEncoder(type: string): (value: any) => string {\n\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return encoder; }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            const length = parseInt(match[3]);\n            return (value: Array<any>) => {\n                if (length >= 0 && value.length !== length) {\n                    logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n                }\n\n                let result = value.map(subEncoder);\n                if (this._types[subtype]) {\n                    result = result.map(keccak256);\n                }\n\n                return keccak256(hexConcat(result));\n            };\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = id(this._types[type]);\n            return (value: Record<string, any>) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this._types[type]) { return keccak256(result); }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return hexConcat(values);\n            }\n        }\n\n        return logger.throwArgumentError(`unknown type: ${ type }`, \"type\", type);\n    }\n\n    encodeType(name: string): string {\n        const result = this._types[name];\n        if (!result) {\n            logger.throwArgumentError(`unknown type: ${ JSON.stringify(name) }`, \"name\", name);\n        }\n        return result;\n    }\n\n    encodeData(type: string, value: any): string {\n        return this.getEncoder(type)(value);\n    }\n\n    hashStruct(name: string, value: Record<string, any>): string {\n        return keccak256(this.encodeData(name, value));\n    }\n\n    encode(value: Record<string, any>): string {\n        return this.encodeData(this.primaryType, value);\n    }\n\n    hash(value: Record<string, any>): string {\n        return this.hashStruct(this.primaryType, value);\n    }\n\n    _visit(type: string, value: any, callback: (type: string, data: any) => any): any {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return callback(type, value); }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const length = parseInt(match[3]);\n            if (length >= 0 && value.length !== length) {\n                logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n            }\n            return value.map((v: any) => this._visit(subtype, v, callback));\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, <Record<string, any>>{});\n        }\n\n        return logger.throwArgumentError(`unknown type: ${ type }`, \"type\", type);\n    }\n\n    visit(value: Record<string, any>, callback: (type: string, data: any) => any): any {\n        return this._visit(this.primaryType, value, callback);\n    }\n\n    static from(types: Record<string, Array<TypedDataField>>): TypedDataEncoder {\n        return new TypedDataEncoder(types);\n    }\n\n    static getPrimaryType(types: Record<string, Array<TypedDataField>>): string {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n\n    static hashStruct(name: string, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n\n    static hashDomain(domain: TypedDataDomain): string {\n        const domainFields: Array<TypedDataField> = [ ];\n        for (const name in domain) {\n            const type = domainFieldTypes[name];\n            if (!type) {\n                logger.throwArgumentError(`invalid typed-data domain key: ${ JSON.stringify(name) }`, \"domain\", domain);\n            }\n            domainFields.push({ name, type });\n        }\n\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n\n    static encode(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return hexConcat([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n\n    static hash(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n\n    // Replaces all address types with ENS names with their looked up address\n    static async resolveNames(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, resolveName: (name: string) => Promise<string>): Promise<{ domain: TypedDataDomain, value: any }> {\n        // Make a copy to isolate it from the object passed in\n        domain = shallowCopy(domain);\n\n        // Look up all ENS names\n        const ensCache: Record<string, string> = { };\n\n        // Do we need to look up the domain's verifyingContract?\n        if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n            ensCache[domain.verifyingContract] = \"0x\";\n        }\n\n        // We are going to use the encoder to visit all the base values\n        const encoder = TypedDataEncoder.from(types);\n\n        // Get a list of all the addresses\n        encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && !isHexString(value, 20)) {\n                ensCache[value] = \"0x\";\n            }\n            return value;\n        });\n\n        // Lookup each name\n        for (const name in ensCache) {\n            ensCache[name] = await resolveName(name);\n        }\n\n        // Replace the domain verifyingContract if needed\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n            domain.verifyingContract = ensCache[domain.verifyingContract];\n        }\n\n        // Replace all ENS names with their address\n        value = encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && ensCache[value]) { return ensCache[value]; }\n            return value;\n        });\n\n        return { domain, value };\n    }\n\n    static getPayload(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): any {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n\n        // Derive the EIP712Domain Struct reference type\n        const domainValues: Record<string, any> = { };\n        const domainTypes: Array<{ name: string, type:string }> = [ ];\n\n        domainFieldNames.forEach((name) => {\n            const value = (<any>domain)[name];\n            if (value == null) { return; }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n\n        const encoder = TypedDataEncoder.from(types);\n\n        const typesWithDomain = shallowCopy(types);\n        if (typesWithDomain.EIP712Domain) {\n            logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        } else {\n            typesWithDomain.EIP712Domain = domainTypes;\n        }\n\n        // Validate the data structures and types\n        encoder.encode(value);\n\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type: string, value: any) => {\n\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return hexlify(arrayify(value));\n                }\n\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return BigNumber.from(value).toString();\n                }\n\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        if (typeof(value) !== \"string\") {\n                            logger.throwArgumentError(`invalid string`, \"value\", value);\n                        }\n                        return value;\n                }\n\n                return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n\n","\"use strict\";\n\n// See: https://github.com/ethereum/wiki/wiki/JSON-RPC\n\nimport { Provider, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { Signer, TypedDataDomain, TypedDataField, TypedDataSigner } from \"@ethersproject/abstract-signer\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { Bytes, hexlify, hexValue, isHexString } from \"@ethersproject/bytes\";\nimport { _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { checkProperties, deepCopy, Deferrable, defineReadOnly, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { AccessList, accessListify } from \"@ethersproject/transactions\";\nimport { ConnectionInfo, fetchJson, poll } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BaseProvider, Event } from \"./base-provider\";\n\n\nconst errorGas = [ \"call\", \"estimateGas\" ];\n\nfunction checkError(method: string, error: any, params: any): any {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n        if (e && e.message.match(\"reverted\") && isHexString(e.data)) {\n            return e.data;\n        }\n\n        logger.throwError(\"missing revert data in call exception\", Logger.errors.CALL_EXCEPTION, {\n            error, data: \"0x\"\n        });\n    }\n\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof(error.error.message) === \"string\") {\n        message = error.error.message;\n    } else if (typeof(error.body) === \"string\") {\n        message = error.body;\n    } else if (typeof(error.responseText) === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n\n    const transaction = params.transaction || params.signedTransaction;\n\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n\n    // \"nonce too low\"\n    if (message.match(/nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced/)) {\n        logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/)) {\n        logger.throwError(\"legacy pre-eip-155 transactions not supported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            error, method, transaction\n        });\n    }\n\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n\n    throw error;\n}\n\nfunction timer(timeout: number): Promise<any> {\n    return new Promise(function(resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\n\nfunction getResult(payload: { error?: { code?: number, data?: any, message?: string }, result?: any }): any {\n    if (payload.error) {\n        // @TODO: not any\n        const error: any = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n\n    return payload.result;\n}\n\nfunction getLowerCase(value: string): string {\n    if (value) { return value.toLowerCase(); }\n    return value;\n}\n\nconst _constructorGuard = {};\n\nexport class JsonRpcSigner extends Signer implements TypedDataSigner {\n    readonly provider: JsonRpcProvider;\n    _index: number;\n    _address: string;\n\n    constructor(constructorGuard: any, provider: JsonRpcProvider, addressOrIndex?: string | number) {\n        logger.checkNew(new.target, JsonRpcSigner);\n\n        super();\n\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n\n        defineReadOnly(this, \"provider\", provider);\n\n        if (addressOrIndex == null) { addressOrIndex = 0; }\n\n        if (typeof(addressOrIndex) === \"string\") {\n            defineReadOnly(this, \"_address\", this.provider.formatter.address(addressOrIndex));\n            defineReadOnly(this, \"_index\", null);\n\n        } else if (typeof(addressOrIndex) === \"number\") {\n            defineReadOnly(this, \"_index\", addressOrIndex);\n            defineReadOnly(this, \"_address\", null);\n\n        } else {\n            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n    }\n\n    connect(provider: Provider): JsonRpcSigner {\n        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    }\n\n    connectUnchecked(): JsonRpcSigner {\n        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n    }\n\n    getAddress(): Promise<string> {\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n\n        return this.provider.send(\"eth_accounts\", []).then((accounts) => {\n            if (accounts.length <= this._index) {\n                logger.throwError(\"unknown account #\" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return this.provider.formatter.address(accounts[this._index])\n        });\n    }\n\n    sendUncheckedTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        transaction = shallowCopy(transaction);\n\n        const fromAddress = this.getAddress().then((address) => {\n            if (address) { address = address.toLowerCase(); }\n            return address;\n        });\n\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            const estimate = shallowCopy(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then(async (to) => {\n                if (to == null) { return null; }\n                const address = await this.provider.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            });\n        }\n\n        return resolveProperties({\n            tx: resolveProperties(transaction),\n            sender: fromAddress\n        }).then(({ tx, sender }) => {\n\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            } else {\n                tx.from = sender;\n            }\n\n            const hexTx = (<any>this.provider.constructor).hexlifyTransaction(tx, { from: true });\n\n            return this.provider.send(\"eth_sendTransaction\", [ hexTx ]).then((hash) => {\n                return hash;\n            }, (error) => {\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    }\n\n    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        return logger.throwError(\"signing transactions is unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    }\n\n    async sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        // This cannot be mined any earlier than any recent block\n        const blockNumber = await this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);\n\n        // Send the transaction\n        const hash = await this.sendUncheckedTransaction(transaction);\n\n        try {\n            // Unfortunately, JSON-RPC only provides and opaque transaction hash\n            // for a response, and we need the actual transaction, so we poll\n            // for it; it should show up very quickly\n            return await poll(async () => {\n                const tx = await this.provider.getTransaction(hash);\n                if (tx === null) { return undefined; }\n                return this.provider._wrapTransaction(tx, hash, blockNumber);\n            }, { oncePoll: this.provider });\n        } catch (error) {\n            (<any>error).transactionHash = hash;\n            throw error;\n        }\n    }\n\n    async signMessage(message: Bytes | string): Promise<string> {\n        const data = ((typeof(message) === \"string\") ? toUtf8Bytes(message): message);\n        const address = await this.getAddress();\n\n        return await this.provider.send(\"personal_sign\", [ hexlify(data), address.toLowerCase() ]);\n    }\n\n    async _legacySignMessage(message: Bytes | string): Promise<string> {\n        const data = ((typeof(message) === \"string\") ? toUtf8Bytes(message): message);\n        const address = await this.getAddress();\n\n        // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n        return await this.provider.send(\"eth_sign\", [ address.toLowerCase(), hexlify(data) ]);\n    }\n\n    async _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        // Populate any ENS names (in-place)\n        const populated = await _TypedDataEncoder.resolveNames(domain, types, value, (name: string) => {\n            return this.provider.resolveName(name);\n        });\n\n        const address = await this.getAddress();\n\n        return await this.provider.send(\"eth_signTypedData_v4\", [\n            address.toLowerCase(),\n            JSON.stringify(_TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n        ]);\n    }\n\n    async unlock(password: string): Promise<boolean> {\n        const provider = this.provider;\n\n        const address = await this.getAddress();\n\n        return provider.send(\"personal_unlockAccount\", [ address.toLowerCase(), password, null ]);\n    }\n}\n\nclass UncheckedJsonRpcSigner extends JsonRpcSigner {\n    sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        return this.sendUncheckedTransaction(transaction).then((hash) => {\n            return <TransactionResponse>{\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: (confirmations?: number) => { return this.provider.waitForTransaction(hash, confirmations); }\n            };\n        });\n    }\n}\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, gasLimit: true, gasPrice:true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true\n}\n\nexport class JsonRpcProvider extends BaseProvider {\n    readonly connection: ConnectionInfo;\n\n    _pendingFilter: Promise<number>;\n    _nextId: number;\n\n    // During any given event loop, the results for a given call will\n    // all be the same, so we can dedup the calls to save requests and\n    // bandwidth. @TODO: Try out generalizing this against send?\n    _eventLoopCache: Record<string, Promise<any>>;\n    get _cache(): Record<string, Promise<any>> {\n        if (this._eventLoopCache == null) {\n            this._eventLoopCache = { };\n        }\n        return this._eventLoopCache;\n    }\n\n    constructor(url?: ConnectionInfo | string, network?: Networkish) {\n        logger.checkNew(new.target, JsonRpcProvider);\n\n        let networkOrReady: Networkish | Promise<Network> = network;\n\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then((network) => {\n                        resolve(network);\n                    }, (error) => {\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n\n        super(networkOrReady);\n\n        // Default URL\n        if (!url) { url = getStatic<() => string>(this.constructor, \"defaultUrl\")(); }\n\n        if (typeof(url) === \"string\") {\n            defineReadOnly(this, \"connection\",Object.freeze({\n                url: url\n            }));\n        } else {\n            defineReadOnly(this, \"connection\", Object.freeze(shallowCopy(url)));\n        }\n\n        this._nextId = 42;\n    }\n\n    static defaultUrl(): string {\n        return \"http:/\\/localhost:8545\";\n    }\n\n    detectNetwork(): Promise<Network> {\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(() => {\n                this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    }\n\n    async _uncachedDetectNetwork(): Promise<Network> {\n        await timer(0);\n\n        let chainId = null;\n        try {\n            chainId = await this.send(\"eth_chainId\", [ ]);\n        } catch (error) {\n            try {\n                chainId = await this.send(\"net_version\", [ ]);\n            } catch (error) { }\n        }\n\n        if (chainId != null) {\n            const getNetwork = getStatic<(network: Networkish) => Network>(this.constructor, \"getNetwork\");\n            try {\n                return getNetwork(BigNumber.from(chainId).toNumber());\n            } catch (error) {\n                return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                    chainId: chainId,\n                    event: \"invalidNetwork\",\n                    serverError: error\n                });\n            }\n        }\n\n        return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n            event: \"noNetwork\"\n        });\n    }\n\n    getSigner(addressOrIndex?: string | number): JsonRpcSigner {\n        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n    }\n\n    getUncheckedSigner(addressOrIndex?: string | number): UncheckedJsonRpcSigner {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    }\n\n    listAccounts(): Promise<Array<string>> {\n        return this.send(\"eth_accounts\", []).then((accounts: Array<string>) => {\n            return accounts.map((a) => this.formatter.address(a));\n        });\n    }\n\n    send(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: deepCopy(request),\n            provider: this\n        });\n\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = ([ \"eth_chainId\", \"eth_blockNumber\" ].indexOf(method) >= 0);\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n\n        const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: this\n            });\n\n            return result;\n\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: this\n            });\n\n            throw error;\n        });\n\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(() => {\n                this._cache[method] = null;\n            }, 0);\n        }\n\n        return result;\n    }\n\n    prepareRequest(method: string, params: any): [ string, Array<any> ] {\n        switch (method) {\n            case \"getBlockNumber\":\n                return [ \"eth_blockNumber\", [] ];\n\n            case \"getGasPrice\":\n                return [ \"eth_gasPrice\", [] ];\n\n            case \"getBalance\":\n                return [ \"eth_getBalance\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getTransactionCount\":\n                return [ \"eth_getTransactionCount\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getCode\":\n                return [ \"eth_getCode\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getStorageAt\":\n                return [ \"eth_getStorageAt\", [ getLowerCase(params.address), params.position, params.blockTag ] ];\n\n            case \"sendTransaction\":\n                return [ \"eth_sendRawTransaction\", [ params.signedTransaction ] ]\n\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [ \"eth_getBlockByNumber\", [ params.blockTag, !!params.includeTransactions ] ];\n                } else if (params.blockHash) {\n                    return [ \"eth_getBlockByHash\", [ params.blockHash, !!params.includeTransactions ] ];\n                }\n                return null;\n\n            case \"getTransaction\":\n                return [ \"eth_getTransactionByHash\", [ params.transactionHash ] ];\n\n            case \"getTransactionReceipt\":\n                return [ \"eth_getTransactionReceipt\", [ params.transactionHash ] ];\n\n            case \"call\": {\n                const hexlifyTransaction = getStatic<(t: TransactionRequest, a?: { [key: string]: boolean }) => { [key: string]: string }>(this.constructor, \"hexlifyTransaction\");\n                return [ \"eth_call\", [ hexlifyTransaction(params.transaction, { from: true }), params.blockTag ] ];\n            }\n\n            case \"estimateGas\": {\n                const hexlifyTransaction = getStatic<(t: TransactionRequest, a?: { [key: string]: boolean }) => { [key: string]: string }>(this.constructor, \"hexlifyTransaction\");\n                return [ \"eth_estimateGas\", [ hexlifyTransaction(params.transaction, { from: true }) ] ];\n            }\n\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [ \"eth_getLogs\", [ params.filter ] ];\n\n            default:\n                break;\n        }\n\n        return null;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n        // Legacy networks do not like the type field being passed along (which\n        // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n        if (method === \"call\" || method === \"estimateGas\") {\n            const tx = params.transaction;\n            if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {\n                // If there are no EIP-1559 properties, it might be non-EIP-a559\n                if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                    const feeData = await this.getFeeData();\n                    if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                        // Network doesn't know about EIP-1559 (and hence type)\n                        params = shallowCopy(params);\n                        params.transaction = shallowCopy(tx);\n                        delete params.transaction.type;\n                    }\n                }\n            }\n        }\n\n        const args = this.prepareRequest(method,  params);\n\n        if (args == null) {\n            logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n        }\n        try {\n            return await this.send(args[0], args[1])\n        } catch (error) {\n            return checkError(method, error, params);\n        }\n    }\n\n    _startEvent(event: Event): void {\n        if (event.tag === \"pending\") { this._startPending(); }\n        super._startEvent(event);\n    }\n\n    _startPending(): void {\n        if (this._pendingFilter != null) { return; }\n        const self = this;\n\n        const pendingFilter: Promise<number> = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n\n        pendingFilter.then(function(filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [ filterId ]).then(function(hashes: Array<string>) {\n                    if (self._pendingFilter != pendingFilter) { return null; }\n\n                    let seq = Promise.resolve();\n                    hashes.forEach(function(hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function() {\n                            return self.getTransaction(hash).then(function(tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n\n                    return seq.then(function() {\n                        return timer(1000);\n                    });\n                }).then(function() {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [ filterId ]);\n                        return;\n                    }\n                    setTimeout(function() { poll(); }, 0);\n\n                    return null;\n                }).catch((error: Error) => { });\n            }\n            poll();\n\n            return filterId;\n        }).catch((error: Error) => { });\n    }\n\n    _stopEvent(event: Event): void {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        super._stopEvent(event);\n    }\n\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    static hexlifyTransaction(transaction: TransactionRequest, allowExtra?: { [key: string]: boolean }): { [key: string]: string | AccessList } {\n        // Check only allowed properties are given\n        const allowed = shallowCopy(allowedTransactionKeys);\n        if (allowExtra) {\n            for (const key in allowExtra) {\n                if (allowExtra[key]) { allowed[key] = true; }\n            }\n        }\n\n        checkProperties(transaction, allowed);\n\n        const result: { [key: string]: string | AccessList } = {};\n\n        // Some nodes (INFURA ropsten; INFURA mainnet is fine) do not like leading zeros.\n        [\"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(function(key) {\n            if ((<any>transaction)[key] == null) { return; }\n            const value = hexValue((<any>transaction)[key]);\n            if (key === \"gasLimit\") { key = \"gas\"; }\n            result[key] = value;\n        });\n\n        [\"from\", \"to\", \"data\"].forEach(function(key) {\n            if ((<any>transaction)[key] == null) { return; }\n            result[key] = hexlify((<any>transaction)[key]);\n        });\n\n        if ((<any>transaction).accessList) {\n            result[\"accessList\"] = accessListify((<any>transaction).accessList);\n        }\n\n        return result;\n    }\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\n\nlet WS: any = null;\n\ntry {\n    WS = (WebSocket as any);\n    if (WS == null) { throw new Error(\"inject please\"); }\n} catch (error) {\n    const logger = new Logger(version);\n    WS = function() {\n        logger.throwError(\"WebSockets not supported in this environment\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new WebSocket()\"\n        });\n    }\n}\n//export default WS;\n//module.exports = WS;\nexport { WS as WebSocket };\n","\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Event } from \"./base-provider\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nimport { WebSocket } from \"./ws\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicates\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\n\nlet NextId = 1;\n\nexport type InflightRequest = {\n     callback: (error: Error, result: any) => void;\n     payload: string;\n};\n\nexport type Subscription = {\n    tag: string;\n    processFunc: (payload: any) => void;\n};\n\n\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\n\nexport class WebSocketProvider extends JsonRpcProvider {\n    readonly _websocket: any;\n    readonly _requests: { [ name: string ]: InflightRequest };\n    readonly _detectNetwork: Promise<Network>;\n\n    // Maps event tag to subscription ID (we dedupe identical events)\n    readonly _subIds: { [ tag: string ]: Promise<string> };\n\n    // Maps Subscription ID to Subscription\n    readonly _subs: { [ name: string ]: Subscription };\n\n    _wsReady: boolean;\n\n    constructor(url: string, network?: Networkish) {\n        // This will be added in the future; please open an issue to expedite\n        if (network === \"any\") {\n            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"network:any\"\n            });\n        }\n\n        super(url, network);\n        this._pollingInterval = -1;\n\n        this._wsReady = false;\n\n        defineReadOnly(this, \"_websocket\", new WebSocket(this.connection.url));\n        defineReadOnly(this, \"_requests\", { });\n        defineReadOnly(this, \"_subs\", { });\n        defineReadOnly(this, \"_subIds\", { });\n        defineReadOnly(this, \"_detectNetwork\", super.detectNetwork());\n\n        // Stall sending requests until the socket is open...\n        this._websocket.onopen = () => {\n            this._wsReady = true;\n            Object.keys(this._requests).forEach((id) => {\n                this._websocket.send(this._requests[id].payload);\n            });\n        };\n\n        this._websocket.onmessage = (messageEvent: { data: string }) => {\n            const data = messageEvent.data;\n            const result = JSON.parse(data);\n            if (result.id != null) {\n                const id = String(result.id);\n                const request = this._requests[id];\n                delete this._requests[id];\n\n                if (result.result !== undefined) {\n                    request.callback(null, result.result);\n\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: JSON.parse(request.payload),\n                        response: result.result,\n                        provider: this\n                    });\n\n                } else {\n                    let error: Error = null;\n                    if (result.error) {\n                        error = new Error(result.error.message || \"unknown error\");\n                        defineReadOnly(<any>error, \"code\", result.error.code || null);\n                        defineReadOnly(<any>error, \"response\", data);\n                    } else {\n                        error = new Error(\"unknown error\");\n                    }\n\n                    request.callback(error, undefined);\n\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: JSON.parse(request.payload),\n                        provider: this\n                    });\n\n                }\n\n            } else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                const sub = this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result)\n                }\n\n            } else {\n                console.warn(\"this should not happen\");\n            }\n        };\n\n        // This Provider does not actually poll, but we want to trigger\n        // poll events for things that depend on them (like stalling for\n        // block and transaction lookups)\n        const fauxPoll = setInterval(() => {\n            this.emit(\"poll\");\n        }, 1000);\n        if (fauxPoll.unref) { fauxPoll.unref(); }\n    }\n\n    detectNetwork(): Promise<Network> {\n        return this._detectNetwork;\n    }\n\n    get pollingInterval(): number {\n        return 0;\n    }\n\n    resetEventsBlock(blockNumber: number): void {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    }\n\n    set pollingInterval(value: number) {\n        logger.throwError(\"cannot set polling interval on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPollingInterval\"\n        });\n    }\n\n    async poll(): Promise<void> {\n        return null;\n    }\n\n    set polling(value: boolean) {\n        if (!value) { return; }\n\n        logger.throwError(\"cannot set polling on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPolling\"\n        });\n    }\n\n    send(method: string, params?: Array<any>): Promise<any> {\n        const rid = NextId++;\n\n        return new Promise((resolve, reject) => {\n            function callback(error: Error, result: any) {\n                if (error) { return reject(error); }\n                return resolve(result);\n            }\n\n            const payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: JSON.parse(payload),\n                provider: this\n            });\n\n            this._requests[String(rid)] = { callback, payload };\n\n            if (this._wsReady) { this._websocket.send(payload); }\n        });\n    }\n\n    static defaultUrl(): string {\n        return \"ws:/\\/localhost:8546\";\n    }\n\n    async _subscribe(tag: string, param: Array<any>, processFunc: (result: any) => void): Promise<void> {\n        let subIdPromise = this._subIds[tag];\n        if (subIdPromise == null) {\n            subIdPromise = Promise.all(param).then((param) => {\n                return this.send(\"eth_subscribe\", param);\n            });\n            this._subIds[tag] = subIdPromise;\n        }\n        const subId = await subIdPromise;\n        this._subs[subId] = { tag, processFunc };\n    }\n\n    _startEvent(event: Event): void {\n        switch (event.type) {\n            case \"block\":\n                this._subscribe(\"block\", [ \"newHeads\" ], (result: any) => {\n                    const blockNumber = BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                });\n                break;\n\n            case \"pending\":\n                this._subscribe(\"pending\", [ \"newPendingTransactions\" ], (result: any) => {\n                    this.emit(\"pending\", result);\n                });\n                break;\n\n            case \"filter\":\n                this._subscribe(event.tag, [ \"logs\", this._getFilter(event.filter) ], (result: any) => {\n                    if (result.removed == null) { result.removed = false; }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                });\n                break;\n\n            case \"tx\": {\n                const emitReceipt = (event: Event) => {\n                    const hash = event.hash;\n                    this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt) { return; }\n                        this.emit(hash, receipt);\n                    });\n                };\n\n                // In case it is already mined\n                emitReceipt(event);\n\n                // To keep things simple, we start up a single newHeads subscription\n                // to keep an eye out for transactions we are watching for.\n                // Starting a subscription for an event (i.e. \"tx\") that is already\n                // running is (basically) a nop.\n                this._subscribe(\"tx\", [ \"newHeads\" ], (result: any) => {\n                    this._events.filter((e) => (e.type === \"tx\")).forEach(emitReceipt);\n                });\n                break;\n            }\n\n            // Nothing is needed\n            case \"debug\":\n            case \"poll\":\n            case \"willPoll\":\n            case \"didPoll\":\n            case \"error\":\n                break;\n\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    }\n\n    _stopEvent(event: Event): void {\n        let tag = event.tag;\n\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e) => (e.type === \"tx\")).length) {\n                return;\n            }\n            tag = \"tx\";\n        } else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n\n        const subId = this._subIds[tag];\n        if (!subId) { return; }\n\n       delete this._subIds[tag];\n       subId.then((subId) => {\n            if (!this._subs[subId]) { return; }\n            delete this._subs[subId];\n            this.send(\"eth_unsubscribe\", [ subId ]);\n        });\n    }\n\n    async destroy(): Promise<void> {\n        // Wait until we have connected before trying to disconnect\n        if (this._websocket.readyState === WebSocket.CONNECTING) {\n            await (new Promise((resolve) => {\n                this._websocket.onopen = function() {\n                    resolve(true);\n                };\n\n                this._websocket.onerror = function() {\n                    resolve(false);\n                };\n            }));\n        }\n\n        // Hangup\n        // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n        this._websocket.close(1000);\n    }\n}\n","\n\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly, getStatic } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { CommunityResourcable } from \"./formatter\";\nimport { JsonRpcProvider, JsonRpcSigner } from \"./json-rpc-provider\";\n\ntype getUrlFunc = (network: Network, apiKey: string) => string | ConnectionInfo;\n\n// A StaticJsonRpcProvider is useful when you *know* for certain that\n// the backend will never change, as it never calls eth_chainId to\n// verify its backend. However, if the backend does change, the effects\n// are undefined and may include:\n// - inconsistent results\n// - locking up the UI\n// - block skew warnings\n// - wrong results\n// If the network is not explicit (i.e. auto-detection is expected), the\n// node MUST be running and available to respond to requests BEFORE this\n// is instantiated.\nexport class StaticJsonRpcProvider extends JsonRpcProvider {\n    async detectNetwork(): Promise<Network> {\n        let network = this.network;\n        if (network == null) {\n            network = await super.detectNetwork();\n\n            if (!network) {\n                logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, { });\n            }\n\n            // If still not set, set it\n            if (this._network == null) {\n                // A static network does not support \"any\"\n                defineReadOnly(this, \"_network\", network);\n\n                this.emit(\"network\", network, null);\n            }\n        }\n        return network;\n    }\n}\n\nexport abstract class UrlJsonRpcProvider extends StaticJsonRpcProvider implements CommunityResourcable {\n    readonly apiKey: any;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        logger.checkAbstract(new.target, UrlJsonRpcProvider);\n\n        // Normalize the Network and API Key\n        network = getStatic<(network: Networkish) => Network>(new.target, \"getNetwork\")(network);\n        apiKey = getStatic<(apiKey: string) => string>(new.target, \"getApiKey\")(apiKey);\n\n        const connection = getStatic<getUrlFunc>(new.target, \"getUrl\")(network, apiKey);\n\n        super(connection, network);\n\n        if (typeof(apiKey) === \"string\") {\n            defineReadOnly(this, \"apiKey\", apiKey);\n        } else if (apiKey != null) {\n            Object.keys(apiKey).forEach((key) => {\n                defineReadOnly<any, any>(this, key, apiKey[key]);\n            });\n        }\n    }\n\n    _startPending(): void {\n        logger.warn(\"WARNING: API provider does not support pending filters\");\n    }\n\n    isCommunityResource(): boolean {\n        return false;\n    }\n\n    getSigner(address?: string): JsonRpcSigner {\n        return logger.throwError(\n            \"API provider does not support signing\",\n            Logger.errors.UNSUPPORTED_OPERATION,\n            { operation: \"getSigner\" }\n        );\n    }\n\n    listAccounts(): Promise<Array<string>> {\n        return Promise.resolve([]);\n    }\n\n    // Return a defaultApiKey if null, otherwise validate the API key\n    static getApiKey(apiKey: any): any {\n        return apiKey;\n    }\n\n    // Returns the url or connection for the given network and API key. The\n    // API key will have been sanitized by the getApiKey first, so any validation\n    // or transformations can be done there.\n    static getUrl(network: Network, apiKey: any): string | ConnectionInfo {\n        return logger.throwError(\"not implemented; sub-classes must override getUrl\", Logger.errors.NOT_IMPLEMENTED, {\n            operation: \"getUrl\"\n        });\n    }\n}\n","\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { CommunityResourcable, showThrottleMessage } from \"./formatter\";\nimport { WebSocketProvider } from \"./websocket-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\n// This key was provided to ethers.js by Alchemy to be used by the\n// default provider, but it is recommended that for your own\n// production environments, that you acquire your own API key at:\n//   https://dashboard.alchemyapi.io\n\nconst defaultApiKey = \"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\"\n\nexport class AlchemyWebSocketProvider extends WebSocketProvider implements CommunityResourcable {\n    readonly apiKey: string;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        const provider = new AlchemyProvider(network, apiKey);\n\n        const url = provider.connection.url.replace(/^http/i, \"ws\")\n                                           .replace(\".alchemyapi.\", \".ws.alchemyapi.\");\n\n        super(url, provider.network);\n        defineReadOnly(this, \"apiKey\", provider.apiKey);\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n\nexport class AlchemyProvider extends UrlJsonRpcProvider {\n\n    static getWebSocketProvider(network?: Networkish, apiKey?: any): AlchemyWebSocketProvider {\n        return new AlchemyWebSocketProvider(network, apiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey == null) { return defaultApiKey; }\n        if (apiKey && typeof(apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey;\n    }\n\n    static getUrl(network: Network, apiKey: string): ConnectionInfo {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"eth-mainnet.alchemyapi.io/v2/\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.alchemyapi.io/v2/\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.alchemyapi.io/v2/\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.alchemyapi.io/v2/\";\n                break;\n            case \"kovan\":\n                host = \"eth-kovan.alchemyapi.io/v2/\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum\":\n                host = \"arb-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum-rinkeby\":\n                host = \"arb-rinkeby.g.alchemy.com/v2/\";\n                break;\n            case \"optimism\":\n                host = \"opt-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"optimism-kovan\":\n                host = \"opt-kovan.g.alchemy.com/v2/\";\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + apiKey),\n            throttleCallback: (attempt: number, url: string) => {\n                if (apiKey === defaultApiKey) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n","\"use strict\";\n\nimport { Network } from \"@ethersproject/networks\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport class CloudflareProvider extends UrlJsonRpcProvider {\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey != null) {\n            logger.throwArgumentError(\"apiKey not supported for cloudflare\", \"apiKey\", apiKey);\n        }\n        return null;\n    }\n\n    static getUrl(network: Network, apiKey?: any): string {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://cloudflare-eth.com/\";\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return host;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n        // The Cloudflare provider does not support eth_blockNumber,\n        // so we get the latest block and pull it from that\n        if (method === \"getBlockNumber\") {\n            const block = await super.perform(\"getBlock\", { blockTag: \"latest\" });\n            return block.number;\n        }\n\n        return super.perform(method, params);\n    }\n}\n","\"use strict\";\n\nimport { BlockTag, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { hexlify, hexValue, isHexString } from \"@ethersproject/bytes\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { ConnectionInfo, fetchJson } from \"@ethersproject/web\";\n\nimport { showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BaseProvider } from \"./base-provider\";\n\n\n// The transaction has already been sanitized by the calls in Provider\nfunction getTransactionPostData(transaction: TransactionRequest): Record<string, string> {\n    const result: Record<string, string> = { };\n    for (let key in transaction) {\n        if ((<any>transaction)[key] == null) { continue; }\n        let value = (<any>transaction)[key];\n        if (key === \"type\" && value === 0) { continue; }\n\n        // Quantity-types require no leading zero, unless 0\n        if ((<any>{ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true })[key]) {\n            value = hexValue(hexlify(value));\n        } else if (key === \"accessList\") {\n            value = \"[\" + accessListify(value).map((set) => {\n                return `{address:\"${ set.address }\",storageKeys:[\"${ set.storageKeys.join('\",\"') }\"]}`;\n            }).join(\",\") + \"]\";\n        } else {\n            value = hexlify(value);\n        }\n        result[key] = value;\n    }\n    return result;\n}\n\nfunction getResult(result: { status?: number, message?: string, result?: any }): any {\n    // getLogs, getHistory have weird success responses\n    if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n        return result.result;\n    }\n\n    if (result.status != 1 || result.message != \"OK\") {\n        const error: any = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        if ((result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n            error.throttleRetry = true;\n        }\n        throw error;\n    }\n\n    return result.result;\n}\n\nfunction getJsonResult(result: { jsonrpc: string, result?: any, error?: { code?: number, data?: any, message?: string} } ): any {\n    // This response indicates we are being throttled\n    if (result && (<any>result).status == 0 && (<any>result).message == \"NOTOK\" && (result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n        const error: any = new Error(\"throttled response\");\n        error.result = JSON.stringify(result);\n        error.throttleRetry = true;\n        throw error;\n    }\n\n    if (result.jsonrpc != \"2.0\") {\n        // @TODO: not any\n        const error: any = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        throw error;\n    }\n\n    if (result.error) {\n        // @TODO: not any\n        const error: any = new Error(result.error.message || \"unknown error\");\n        if (result.error.code) { error.code = result.error.code; }\n        if (result.error.data) { error.data = result.error.data; }\n        throw error;\n    }\n\n    return result.result;\n}\n\n// The blockTag was normalized as a string by the Provider pre-perform operations\nfunction checkLogTag(blockTag: string): number | \"latest\" {\n    if (blockTag === \"pending\") { throw new Error(\"pending not supported\"); }\n    if (blockTag === \"latest\") { return blockTag; }\n\n    return parseInt(blockTag.substring(2), 16);\n}\n\n\nconst defaultApiKey = \"9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB\";\n\nfunction checkError(method: string, error: any, transaction: any): any {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n\n        // Etherscan keeps changing their string\n        if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {\n            // Etherscan prefixes the data like \"Reverted 0x1234\"\n            let data = e.data;\n            if (data) { data = \"0x\" + data.replace(/^.*0x/i, \"\"); }\n\n            if (isHexString(data)) { return data; }\n\n            logger.throwError(\"missing revert data in call exception\", Logger.errors.CALL_EXCEPTION, {\n                error, data: \"0x\"\n            });\n        }\n    }\n\n    // Get the message from any nested error structure\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR) {\n        if (error.error && typeof(error.error.message) === \"string\") {\n            message = error.error.message;\n        } else if (typeof(error.body) === \"string\") {\n            message = error.body;\n        } else if (typeof(error.responseText) === \"string\") {\n            message = error.responseText;\n        }\n    }\n    message = (message || \"\").toLowerCase();\n\n    // \"Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0\"\n    if (message.match(/insufficient funds/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n           error, method, transaction\n        });\n    }\n\n    // \"Transaction with the same hash was already imported.\"\n    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n           error, method, transaction\n        });\n    }\n\n    // \"Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce.\"\n    if (message.match(/another transaction with same nonce/)) {\n         logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n         });\n    }\n\n    if (message.match(/execution failed due to an exception|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n\n    throw error;\n}\n\nexport class EtherscanProvider extends BaseProvider{\n    readonly baseUrl: string;\n    readonly apiKey: string;\n\n    constructor(network?: Networkish, apiKey?: string) {\n        logger.checkNew(new.target, EtherscanProvider);\n\n        super(network);\n\n        defineReadOnly(this, \"baseUrl\", this.getBaseUrl());\n        defineReadOnly(this, \"apiKey\", apiKey || defaultApiKey);\n    }\n\n    getBaseUrl(): string {\n        switch(this.network ? this.network.name: \"invalid\") {\n            case \"homestead\":\n                return \"https:/\\/api.etherscan.io\";\n            case \"ropsten\":\n                return \"https:/\\/api-ropsten.etherscan.io\";\n            case \"rinkeby\":\n                return \"https:/\\/api-rinkeby.etherscan.io\";\n            case \"kovan\":\n                return \"https:/\\/api-kovan.etherscan.io\";\n            case \"goerli\":\n                return \"https:/\\/api-goerli.etherscan.io\";\n            default:\n        }\n\n        return logger.throwArgumentError(\"unsupported network\", \"network\", name);\n    }\n\n    getUrl(module: string, params: Record<string, string>): string {\n        const query = Object.keys(params).reduce((accum, key) => {\n            const value = params[key];\n            if (value != null) {\n                accum += `&${ key }=${ value }`\n            }\n            return accum\n        }, \"\");\n        const apiKey = ((this.apiKey) ? `&apikey=${ this.apiKey }`: \"\");\n        return `${ this.baseUrl }/api?module=${ module }${ query }${ apiKey }`;\n    }\n\n    getPostUrl(): string {\n        return `${ this.baseUrl }/api`;\n    }\n\n    getPostData(module: string, params: Record<string, any>): Record<string, any> {\n        params.module = module;\n        params.apikey = this.apiKey;\n        return params;\n    }\n\n    async fetch(module: string, params: Record<string, any>, post?: boolean): Promise<any> {\n        const url = (post ? this.getPostUrl(): this.getUrl(module, params));\n        const payload = (post ? this.getPostData(module, params): null);\n        const procFunc = (module === \"proxy\") ? getJsonResult: getResult;\n\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: url,\n            provider: this\n        });\n\n        const connection: ConnectionInfo = {\n            url: url,\n            throttleSlotInterval: 1000,\n            throttleCallback: (attempt: number, url: string) => {\n                if (this.isCommunityResource()) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n\n        let payloadStr: string = null;\n        if (payload) {\n            connection.headers = { \"content-type\": \"application/x-www-form-urlencoded; charset=UTF-8\" };\n            payloadStr = Object.keys(payload).map((key) => {\n                return `${ key }=${ payload[key] }`\n            }).join(\"&\");\n        }\n\n        const result = await fetchJson(connection, payloadStr, procFunc || getJsonResult);\n\n        this.emit(\"debug\", {\n            action: \"response\",\n            request: url,\n            response: deepCopy(result),\n            provider: this\n        });\n\n        return result;\n    }\n\n    async detectNetwork(): Promise<Network> {\n        return this.network;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n\n        switch (method) {\n            case \"getBlockNumber\":\n                return this.fetch(\"proxy\", { action: \"eth_blockNumber\" });\n\n            case \"getGasPrice\":\n                return this.fetch(\"proxy\", { action: \"eth_gasPrice\" });\n\n            case \"getBalance\":\n                // Returns base-10 result\n                return this.fetch(\"account\", {\n                    action: \"balance\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getTransactionCount\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionCount\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getCode\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getCode\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getStorageAt\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getStorageAt\",\n                    address: params.address,\n                    position: params.position,\n                    tag: params.blockTag\n                });\n\n            case \"sendTransaction\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_sendRawTransaction\",\n                    hex: params.signedTransaction\n                }, true).catch((error) => {\n                    return checkError(\"sendTransaction\", error, params.signedTransaction);\n                });\n\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getBlockByNumber\",\n                        tag: params.blockTag,\n                        boolean: (params.includeTransactions ? \"true\": \"false\")\n                    });\n                }\n                throw new Error(\"getBlock by blockHash not implemented\");\n\n            case \"getTransaction\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionByHash\",\n                    txhash: params.transactionHash\n                });\n\n            case \"getTransactionReceipt\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionReceipt\",\n                    txhash: params.transactionHash\n                });\n\n            case \"call\": {\n                if (params.blockTag !== \"latest\") {\n                    throw new Error(\"EtherscanProvider does not support blockTag for call\");\n                }\n\n                const postData = getTransactionPostData(params.transaction);\n                postData.module = \"proxy\";\n                postData.action = \"eth_call\";\n\n                try {\n                    return await this.fetch(\"proxy\", postData, true);\n                } catch (error) {\n                    return checkError(\"call\", error, params.transaction);\n                }\n            }\n\n            case \"estimateGas\": {\n                const postData = getTransactionPostData(params.transaction);\n                postData.module = \"proxy\";\n                postData.action = \"eth_estimateGas\";\n\n                try {\n                    return await this.fetch(\"proxy\", postData, true);\n                } catch (error) {\n                    return checkError(\"estimateGas\", error, params.transaction);\n                }\n            }\n\n            case \"getLogs\": {\n                const args: Record<string, any> = { action: \"getLogs\" }\n\n                if (params.filter.fromBlock) {\n                    args.fromBlock = checkLogTag(params.filter.fromBlock);\n                }\n\n                if (params.filter.toBlock) {\n                    args.toBlock = checkLogTag(params.filter.toBlock);\n                }\n\n                if (params.filter.address) {\n                    args.address = params.filter.address;\n                }\n\n                // @TODO: We can handle slightly more complicated logs using the logs API\n                if (params.filter.topics && params.filter.topics.length > 0) {\n                    if (params.filter.topics.length > 1) {\n                        logger.throwError(\"unsupported topic count\", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\n                    }\n\n                    if (params.filter.topics.length === 1) {\n                        const topic0 = params.filter.topics[0];\n                        if (typeof(topic0) !== \"string\" || topic0.length !== 66) {\n                            logger.throwError(\"unsupported topic format\", Logger.errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\n                        }\n                        args.topic0 = topic0;\n                    }\n                }\n\n                const logs: Array<any> = await this.fetch(\"logs\", args);\n\n                // Cache txHash => blockHash\n                let blocks: { [tag: string]: string } = {};\n\n                // Add any missing blockHash to the logs\n                for (let i = 0; i < logs.length; i++) {\n                    const log = logs[i];\n                    if (log.blockHash != null) { continue; }\n                    if (blocks[log.blockNumber] == null) {\n                        const block = await this.getBlock(log.blockNumber);\n                        if (block) {\n                            blocks[log.blockNumber] = block.hash;\n                        }\n                    }\n                    log.blockHash = blocks[log.blockNumber];\n                }\n\n                return logs;\n            }\n\n            case \"getEtherPrice\":\n                if (this.network.name !== \"homestead\") { return 0.0; }\n                return parseFloat((await this.fetch(\"stats\", { action: \"ethprice\" })).ethusd);\n\n            default:\n                break;\n         }\n\n        return super.perform(method, params);\n    }\n\n    // Note: The `page` page parameter only allows pagination within the\n    //       10,000 window available without a page and offset parameter\n    //       Error: Result window is too large, PageNo x Offset size must\n    //              be less than or equal to 10000\n    async getHistory(addressOrName: string | Promise<string>, startBlock?: BlockTag, endBlock?: BlockTag): Promise<Array<TransactionResponse>> {\n        const params = {\n            action: \"txlist\",\n            address: (await this.resolveName(addressOrName)),\n            startblock: ((startBlock == null) ? 0: startBlock),\n            endblock: ((endBlock == null) ? 99999999: endBlock),\n            sort: \"asc\"\n        };\n\n        const result = await this.fetch(\"account\", params);\n\n        return result.map((tx: any) => {\n            [\"contractAddress\", \"to\"].forEach(function(key) {\n                if (tx[key] == \"\") { delete tx[key]; }\n            });\n            if (tx.creates == null && tx.contractAddress != null) {\n                tx.creates = tx.contractAddress;\n            }\n            const item = this.formatter.transactionResponse(tx);\n            if (tx.timeStamp) { item.timestamp = parseInt(tx.timeStamp); }\n            return item;\n        });\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n","\"use strict\";\n\nexport function shuffled(array: Array<any>): Array<any> {\n    array = array.slice();\n\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        const tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n\n    return array;\n}\n","\"use strict\";\n\nimport { Block, BlockWithTransactions, Provider } from \"@ethersproject/abstract-provider\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { Network } from \"@ethersproject/networks\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { shuffled } from \"@ethersproject/random\";\nimport { poll } from \"@ethersproject/web\";\n\nimport { BaseProvider } from \"./base-provider\";\nimport { isCommunityResource } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction now() { return (new Date()).getTime(); }\n\n// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks: Array<Network>): Network {\n    let result = null;\n\n    for (let i = 0; i < networks.length; i++) {\n        const network = networks[i];\n\n        // Null! We do not know our network; bail.\n        if (network == null) { return null; }\n\n        if (result) {\n            // Make sure the network matches the previous networks\n            if (!(result.name === network.name && result.chainId === network.chainId &&\n                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {\n\n                logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n           }\n        } else {\n            result = network;\n        }\n    }\n\n    return result;\n}\n\nfunction median(values: Array<number>, maxDelta?: number): number {\n    values = values.slice().sort();\n    const middle = Math.floor(values.length / 2);\n\n    // Odd length; take the middle\n    if (values.length % 2) {\n        return values[middle];\n    }\n\n    // Even length; take the average of the two middle\n    const a = values[middle - 1], b = values[middle];\n\n    if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n        return null;\n    }\n\n    return (a + b) / 2;\n}\n\nfunction serialize(value: any): string {\n    if (value === null) {\n        return \"null\";\n    } else if (typeof(value) === \"number\" || typeof(value) === \"boolean\") {\n        return JSON.stringify(value);\n    } else if (typeof(value) === \"string\") {\n        return value;\n    } else if (BigNumber.isBigNumber(value)) {\n        return value.toString();\n    } else if (Array.isArray(value)) {\n        return JSON.stringify(value.map((i) => serialize(i)));\n    } else if (typeof(value) === \"object\") {\n        const keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map((key) => {\n            let v = value[key];\n            if (typeof(v) === \"function\") {\n                v = \"[function]\";\n            } else {\n                v = serialize(v);\n            }\n            return JSON.stringify(key) + \":\" + v;\n        }).join(\",\") + \"}\";\n    }\n\n    throw new Error(\"unknown value type: \" + typeof(value));\n}\n\n// Next request ID to use for emitting debug info\nlet nextRid = 1;\n\n\nexport interface FallbackProviderConfig {\n    // The Provider\n    provider: Provider;\n\n    // The priority to favour this Provider; lower values are used first (higher priority)\n    priority?: number;\n\n    // Timeout before also triggering the next provider; this does not stop\n    // this provider and if its result comes back before a quorum is reached\n    // it will be incorporated into the vote\n    // - lower values will cause more network traffic but may result in a\n    //   faster result.\n    stallTimeout?: number;\n\n    // How much this provider contributes to the quorum; sometimes a specific\n    // provider may be more reliable or trustworthy than others, but usually\n    // this should be left as the default\n    weight?: number;\n};\n\n// A Staller is used to provide a delay to give a Provider a chance to response\n// before asking the next Provider to try.\ntype Staller = {\n    wait: (func: () => void) => Promise<void>\n    getPromise: () => Promise<void>,\n    cancel: () => void\n};\n\nfunction stall(duration: number): Staller {\n    let cancel: () => void = null;\n\n    let timer: NodeJS.Timer = null;\n    let promise = <Promise<void>>(new Promise((resolve) => {\n        cancel = function() {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            resolve();\n        }\n        timer = setTimeout(cancel, duration);\n    }));\n\n    const wait = (func: () => void) => {\n        promise = promise.then(func);\n        return promise;\n    }\n\n    function getPromise(): Promise<void> {\n        return promise;\n    }\n\n    return { cancel, getPromise, wait };\n}\n\nconst ForwardErrors = [\n    Logger.errors.CALL_EXCEPTION,\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n    Logger.errors.UNPREDICTABLE_GAS_LIMIT\n];\n\nconst ForwardProperties = [\n    \"address\",\n    \"args\",\n    \"errorArgs\",\n    \"errorSignature\",\n    \"method\",\n    \"transaction\",\n];\n\n\n// @TODO: Make this an object with staller and cancel built-in\ninterface RunningConfig extends FallbackProviderConfig {\n    start?: number;\n    done?: boolean;\n    cancelled?: boolean;\n    runner?: Promise<any>;\n    staller?: Staller;\n    result?: any;\n    error?: Error;\n};\n\nfunction exposeDebugConfig(config: RunningConfig, now?: number): any {\n    const result: any = {\n        weight: config.weight\n    };\n    Object.defineProperty(result, \"provider\", { get: () => config.provider });\n    if (config.start) { result.start = config.start; }\n    if (now) { result.duration = (now - config.start); }\n    if (config.done) {\n        if (config.error) {\n            result.error = config.error;\n        } else {\n            result.result = config.result || null;\n        }\n    }\n    return result;\n}\n\nfunction normalizedTally(normalize: (value: any) => string, quorum: number): (configs: Array<RunningConfig>) => any {\n    return function(configs: Array<RunningConfig>): any {\n\n        // Count the votes for each result\n        const tally: { [ key: string]: { count: number, result: any } } = { };\n        configs.forEach((c) => {\n            const value = normalize(c.result);\n            if (!tally[value]) { tally[value] = { count: 0, result: c.result }; }\n            tally[value].count++;\n        });\n\n        // Check for a quorum on any given result\n        const keys = Object.keys(tally);\n        for (let i = 0; i < keys.length; i++) {\n            const check = tally[keys[i]];\n            if (check.count >= quorum) {\n                return check.result;\n            }\n        }\n\n        // No quroum\n        return undefined;\n    }\n}\nfunction getProcessFunc(provider: FallbackProvider, method: string, params: { [ key: string ]: any }): (configs: Array<RunningConfig>) => any {\n\n    let normalize = serialize;\n\n    switch (method) {\n        case \"getBlockNumber\":\n            // Return the median value, unless there is (median + 1) is also\n            // present, in which case that is probably true and the median\n            // is going to be stale soon. In the event of a malicious node,\n            // the lie will be true soon enough.\n            return function(configs: Array<RunningConfig>): number {\n                const values = configs.map((c) => c.result);\n\n                // Get the median block number\n                let blockNumber = median(configs.map((c) => c.result), 2);\n                if (blockNumber == null) { return undefined; }\n\n                blockNumber = Math.ceil(blockNumber);\n\n                // If the next block height is present, its prolly safe to use\n                if (values.indexOf(blockNumber + 1) >= 0) { blockNumber++; }\n\n                // Don't ever roll back the blockNumber\n                if (blockNumber >= provider._highestBlockNumber) {\n                    provider._highestBlockNumber = blockNumber;\n                }\n\n                return provider._highestBlockNumber;\n            };\n\n        case \"getGasPrice\":\n            // Return the middle (round index up) value, similar to median\n            // but do not average even entries and choose the higher.\n            // Malicious actors must compromise 50% of the nodes to lie.\n            return function(configs: Array<RunningConfig>): BigNumber {\n                const values = configs.map((c) => c.result);\n                values.sort();\n                return values[Math.floor(values.length / 2)];\n            }\n\n        case \"getEtherPrice\":\n            // Returns the median price. Malicious actors must compromise at\n            // least 50% of the nodes to lie (in a meaningful way).\n            return function(configs: Array<RunningConfig>): number {\n                return median(configs.map((c) => c.result));\n            }\n\n        // No additional normalizing required; serialize is enough\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n        case \"getStorageAt\":\n        case \"call\":\n        case \"estimateGas\":\n        case \"getLogs\":\n            break;\n\n        // We drop the confirmations from transactions as it is approximate\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            normalize = function(tx: any): string {\n                if (tx == null) { return null; }\n\n                tx = shallowCopy(tx);\n                tx.confirmations = -1;\n                return serialize(tx);\n            }\n            break;\n\n        // We drop the confirmations from transactions as it is approximate\n        case \"getBlock\":\n            // We drop the confirmations from transactions as it is approximate\n            if (params.includeTransactions) {\n                normalize = function(block: BlockWithTransactions): string {\n                    if (block == null) { return null; }\n\n                    block = shallowCopy(block);\n                    block.transactions = block.transactions.map((tx) => {\n                        tx = shallowCopy(tx);\n                        tx.confirmations = -1;\n                        return tx;\n                    });\n                    return serialize(block);\n                };\n            } else {\n                normalize = function(block: Block): string {\n                    if (block == null) { return null; }\n                    return serialize(block);\n                }\n            }\n            break;\n\n        default:\n            throw new Error(\"unknown method: \" + method);\n    }\n\n    // Return the result if and only if the expected quorum is\n    // satisfied and agreed upon for the final result.\n    return normalizedTally(normalize, provider.quorum);\n\n}\n\n// If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\nasync function waitForSync(config: RunningConfig, blockNumber: number): Promise<BaseProvider> {\n    const provider = <BaseProvider>(config.provider);\n\n    if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {\n        return provider;\n    }\n\n    return poll(() => {\n        return new Promise((resolve, reject) => {\n            setTimeout(function() {\n\n                // We are synced\n                if (provider.blockNumber >= blockNumber) { return resolve(provider); }\n\n                // We're done; just quit\n                if (config.cancelled) { return resolve(null); }\n\n                // Try again, next block\n                return resolve(undefined);\n            }, 0);\n        });\n    }, { oncePoll: provider });\n}\n\nasync function getRunner(config: RunningConfig, currentBlockNumber: number, method: string, params: { [ key: string]: any }): Promise<any> {\n    let provider = config.provider;\n\n    switch (method) {\n        case \"getBlockNumber\":\n        case \"getGasPrice\":\n            return provider[method]();\n        case \"getEtherPrice\":\n            if ((<any>provider).getEtherPrice) {\n                return (<any>provider).getEtherPrice();\n            }\n            break;\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[method](params.address, params.blockTag || \"latest\");\n        case \"getStorageAt\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\");\n        case \"getBlock\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[(params.includeTransactions ? \"getBlockWithTransactions\": \"getBlock\")](params.blockTag || params.blockHash);\n        case \"call\":\n        case \"estimateGas\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[method](params.transaction);\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            return provider[method](params.transactionHash);\n        case \"getLogs\": {\n            let filter = params.filter;\n            if ((filter.fromBlock && isHexString(filter.fromBlock)) || (filter.toBlock && isHexString(filter.toBlock))) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider.getLogs(filter);\n        }\n    }\n\n    return logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\n        method: method,\n        params: params\n    });\n}\n\nexport class FallbackProvider extends BaseProvider {\n    readonly providerConfigs: ReadonlyArray<FallbackProviderConfig>;\n    readonly quorum: number;\n\n    // Due to the highly asyncronous nature of the blockchain, we need\n    // to make sure we never unroll the blockNumber due to our random\n    // sample of backends\n    _highestBlockNumber: number;\n\n    constructor(providers: Array<Provider | FallbackProviderConfig>, quorum?: number) {\n        logger.checkNew(new.target, FallbackProvider);\n\n        if (providers.length === 0) {\n            logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n        }\n\n        const providerConfigs: Array<FallbackProviderConfig> = providers.map((configOrProvider, index) => {\n            if (Provider.isProvider(configOrProvider)) {\n                const stallTimeout = isCommunityResource(configOrProvider) ? 2000: 750;\n                const priority = 1;\n                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });\n            }\n\n            const config: FallbackProviderConfig = shallowCopy(configOrProvider);\n\n            if (config.priority == null) { config.priority = 1; }\n            if (config.stallTimeout == null) {\n                config.stallTimeout = isCommunityResource(configOrProvider) ? 2000: 750;\n            }\n            if (config.weight == null) { config.weight = 1; }\n\n            const weight = config.weight;\n            if (weight % 1 || weight > 512 || weight < 1) {\n                logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", `providers[${ index }].weight`, weight);\n            }\n\n            return Object.freeze(config);\n        });\n\n        const total = providerConfigs.reduce((accum, c) => (accum + c.weight), 0);\n\n        if (quorum == null) {\n            quorum = total / 2;\n        } else if (quorum > total) {\n            logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n        }\n\n        // Are all providers' networks are known\n        let networkOrReady: Network | Promise<Network> = checkNetworks(providerConfigs.map((c) => (<any>(c.provider)).network));\n\n        // Not all networks are known; we must stall\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then(resolve, reject);\n                }, 0);\n            });\n        }\n\n        super(networkOrReady);\n\n        // Preserve a copy, so we do not get mutated\n        defineReadOnly(this, \"providerConfigs\", Object.freeze(providerConfigs));\n        defineReadOnly(this, \"quorum\", quorum);\n\n        this._highestBlockNumber = -1;\n    }\n\n    async detectNetwork(): Promise<Network> {\n        const networks = await Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));\n        return checkNetworks(networks);\n    }\n\n    async perform(method: string, params: { [name: string]: any }): Promise<any> {\n        // Sending transactions is special; always broadcast it to all backends\n        if (method === \"sendTransaction\") {\n            const results: Array<string | Error> = await Promise.all(this.providerConfigs.map((c) => {\n                return c.provider.sendTransaction(params.signedTransaction).then((result) => {\n                    return result.hash;\n                }, (error) => {\n                    return error;\n                });\n            }));\n\n            // Any success is good enough (other errors are likely \"already seen\" errors\n            for (let i = 0; i < results.length; i++) {\n                const result = results[i];\n                if (typeof(result) === \"string\") { return result; }\n            }\n\n            // They were all an error; pick the first error\n            throw results[0];\n        }\n\n        // We need to make sure we are in sync with our backends, so we need\n        // to know this before we can make a lot of calls\n        if (this._highestBlockNumber === -1 && method !== \"getBlockNumber\") {\n            await this.getBlockNumber();\n        }\n\n        const processFunc = getProcessFunc(this, method, params);\n\n        // Shuffle the providers and then sort them by their priority; we\n        // shallowCopy them since we will store the result in them too\n        const configs: Array<RunningConfig> = shuffled(this.providerConfigs.map(shallowCopy));\n        configs.sort((a, b) => (a.priority - b.priority));\n\n        const currentBlockNumber = this._highestBlockNumber;\n\n        let i = 0;\n        let first = true;\n        while (true) {\n            const t0 = now();\n\n            // Compute the inflight weight (exclude anything past)\n            let inflightWeight = configs.filter((c) => (c.runner && ((t0 - c.start) < c.stallTimeout)))\n                                        .reduce((accum, c) => (accum + c.weight), 0);\n\n            // Start running enough to meet quorum\n            while (inflightWeight < this.quorum && i < configs.length) {\n                const config = configs[i++];\n\n                const rid = nextRid++;\n\n                config.start = now();\n                config.staller = stall(config.stallTimeout);\n                config.staller.wait(() => { config.staller = null; });\n\n                config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {\n                    config.done = true;\n                    config.result = result;\n\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, now()),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                     }\n\n                }, (error) => {\n                    config.done = true;\n                    config.error = error;\n\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, now()),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                    }\n                });\n\n                if (this.listenerCount(\"debug\")) {\n                    this.emit(\"debug\", {\n                        action: \"request\",\n                        rid: rid,\n                        backend: exposeDebugConfig(config, null),\n                        request: { method: method, params: deepCopy(params) },\n                        provider: this\n                    });\n                }\n\n                inflightWeight += config.weight;\n            }\n\n            // Wait for anything meaningful to finish or stall out\n            const waiting: Array<Promise<any>> = [ ];\n            configs.forEach((c) => {\n                if (c.done || !c.runner) { return; }\n                waiting.push(c.runner);\n                if (c.staller) { waiting.push(c.staller.getPromise()); }\n            });\n\n            if (waiting.length) { await Promise.race(waiting); }\n\n            // Check the quorum and process the results; the process function\n            // may additionally decide the quorum is not met\n            const results = configs.filter((c) => (c.done && c.error == null));\n            if (results.length >= this.quorum) {\n                const result = processFunc(results);\n                if (result !== undefined) {\n                    // Shut down any stallers\n                    configs.forEach(c => {\n                        if (c.staller) { c.staller.cancel(); }\n                        c.cancelled = true;\n                    });\n                    return result;\n                }\n                if (!first) { await stall(100).getPromise(); }\n                first = false;\n            }\n\n            // No result, check for errors that should be forwarded\n            const errors = configs.reduce((accum, c) => {\n                if (!c.done || c.error == null) { return accum; }\n\n                const code = (<any>(c.error)).code;\n                if (ForwardErrors.indexOf(code) >= 0) {\n                    if (!accum[code]) { accum[code] = { error: c.error, weight: 0 }; }\n                    accum[code].weight += c.weight;\n                }\n\n                return accum;\n            }, <{ [ code: string ]: { error: Error, weight: number } }>({ }));\n\n            Object.keys(errors).forEach((errorCode: string) => {\n                const tally = errors[errorCode];\n                if (tally.weight < this.quorum) { return; }\n\n                // Shut down any stallers\n                configs.forEach(c => {\n                    if (c.staller) { c.staller.cancel(); }\n                    c.cancelled = true;\n                });\n\n                const e = <any>(tally.error);\n\n                const props: { [ name: string ]: any } = { };\n                ForwardProperties.forEach((name) => {\n                    if (e[name] == null) { return; }\n                    props[name] = e[name];\n                });\n\n                logger.throwError(e.reason || e.message, <any>errorCode, props);\n            });\n\n            // All configs have run to completion; we will never get more data\n            if (configs.filter((c) => !c.done).length === 0) { break; }\n        }\n\n        // Shut down any stallers; shouldn't be any\n        configs.forEach(c => {\n            if (c.staller) { c.staller.cancel(); }\n            c.cancelled = true;\n        });\n\n        return logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\n            method: method,\n            params: params,\n            //results: configs.map((c) => c.result),\n            //errors: configs.map((c) => c.error),\n            results: configs.map((c) => exposeDebugConfig(c)),\n            provider: this\n        });\n    }\n}\n","\"use strict\";\n\nconst IpcProvider: any = null;\n\nexport {\n    IpcProvider\n};\n","\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { CommunityResourcable, showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\n\nconst defaultProjectId = \"84842078b09946638c03157f83405213\"\n\nexport class InfuraWebSocketProvider extends WebSocketProvider implements CommunityResourcable {\n    readonly apiKey: string;\n    readonly projectId: string;\n    readonly projectSecret: string;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        const provider = new InfuraProvider(network, apiKey);\n        const connection = provider.connection;\n        if (connection.password) {\n            logger.throwError(\"INFURA WebSocket project secrets unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"InfuraProvider.getWebSocketProvider()\"\n            });\n        }\n\n        const url = connection.url.replace(/^http/i, \"ws\").replace(\"/v3/\", \"/ws/v3/\");\n        super(url, network);\n\n        defineReadOnly(this, \"apiKey\", provider.projectId);\n        defineReadOnly(this, \"projectId\", provider.projectId);\n        defineReadOnly(this, \"projectSecret\", provider.projectSecret);\n    }\n\n    isCommunityResource(): boolean {\n        return (this.projectId === defaultProjectId);\n    }\n}\n\nexport class InfuraProvider extends UrlJsonRpcProvider {\n    readonly projectId: string;\n    readonly projectSecret: string;\n\n    static getWebSocketProvider(network?: Networkish, apiKey?: any): InfuraWebSocketProvider {\n        return new InfuraWebSocketProvider(network, apiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        const apiKeyObj: { apiKey: string, projectId: string, projectSecret: string } = {\n            apiKey: defaultProjectId,\n            projectId: defaultProjectId,\n            projectSecret: null\n        };\n\n        if (apiKey == null) { return apiKeyObj; }\n\n        if (typeof(apiKey) === \"string\") {\n            apiKeyObj.projectId = apiKey;\n\n        } else if (apiKey.projectSecret != null) {\n            logger.assertArgument((typeof(apiKey.projectId) === \"string\"),\n                \"projectSecret requires a projectId\", \"projectId\", apiKey.projectId);\n            logger.assertArgument((typeof(apiKey.projectSecret) === \"string\"),\n                \"invalid projectSecret\", \"projectSecret\", \"[REDACTED]\");\n\n            apiKeyObj.projectId = apiKey.projectId;\n            apiKeyObj.projectSecret = apiKey.projectSecret;\n\n        } else if (apiKey.projectId) {\n            apiKeyObj.projectId = apiKey.projectId;\n        }\n\n        apiKeyObj.apiKey = apiKeyObj.projectId;\n\n        return apiKeyObj;\n    }\n\n    static getUrl(network: Network, apiKey: any): ConnectionInfo {\n        let host: string = null;\n        switch(network ? network.name: \"unknown\") {\n            case \"homestead\":\n                host = \"mainnet.infura.io\";\n                break;\n            case \"ropsten\":\n                host = \"ropsten.infura.io\";\n                break;\n            case \"rinkeby\":\n                host = \"rinkeby.infura.io\";\n                break;\n            case \"kovan\":\n                host = \"kovan.infura.io\";\n                break;\n            case \"goerli\":\n                host = \"goerli.infura.io\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.infura.io\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.infura.io\";\n                break;\n            case \"optimism\":\n                host = \"optimism-mainnet.infura.io\";\n                break;\n            case \"optimism-kovan\":\n                host = \"optimism-kovan.infura.io\";\n                break;\n            case \"arbitrum\":\n                host = \"arbitrum-mainnet.infura.io\";\n                break;\n            case \"arbitrum-rinkeby\":\n                host = \"arbitrum-rinkeby.infura.io\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n\n        const connection: ConnectionInfo = {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + \"/v3/\" + apiKey.projectId),\n            throttleCallback: (attempt: number, url: string) => {\n                if (apiKey.projectId === defaultProjectId) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret\n        }\n\n        return connection;\n    }\n\n    isCommunityResource(): boolean {\n        return (this.projectId === defaultProjectId);\n    }\n}\n","\nimport { deepCopy } from \"@ethersproject/properties\";\nimport { fetchJson } from \"@ethersproject/web\";\n\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n\n// Experimental\n\nexport class JsonRpcBatchProvider extends JsonRpcProvider {\n    _pendingBatchAggregator: NodeJS.Timer;\n    _pendingBatch: Array<{\n        request: { method: string, params: Array<any>, id: number, jsonrpc: \"2.0\" },\n        resolve: (result: any) => void,\n        reject: (error: Error) => void\n    }>;\n\n    send(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        if (this._pendingBatch == null) {\n            this._pendingBatch = [ ];\n        }\n\n        const inflightRequest: any = { request, resolve: null, reject: null };\n\n        const promise = new Promise((resolve, reject) => {\n            inflightRequest.resolve = resolve;\n            inflightRequest.reject = reject;\n        });\n\n        this._pendingBatch.push(inflightRequest);\n\n        if (!this._pendingBatchAggregator) {\n            // Schedule batch for next event loop + short duration\n            this._pendingBatchAggregator = setTimeout(() => {\n\n                // Get teh current batch and clear it, so new requests\n                // go into the next batch\n                const batch = this._pendingBatch;\n                this._pendingBatch = null;\n                this._pendingBatchAggregator = null;\n\n                // Get the request as an array of requests\n                const request = batch.map((inflight) => inflight.request);\n\n                this.emit(\"debug\", {\n                    action: \"requestBatch\",\n                    request: deepCopy(request),\n                    provider: this\n                });\n\n                return fetchJson(this.connection, JSON.stringify(request)).then((result) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: request,\n                        response: result,\n                        provider: this\n                    });\n\n                    // For each result, feed it to the correct Promise, depending\n                    // on whether it was a success or error\n                    batch.forEach((inflightRequest, index) => {\n                        const payload = result[index];\n                        if (payload.error) {\n                            const error = new Error(payload.error.message);\n                            (<any>error).code = payload.error.code;\n                            (<any>error).data = payload.error.data;\n                            inflightRequest.reject(error);\n                        } else {\n                            inflightRequest.resolve(payload.result);\n                        }\n                    });\n\n                }, (error) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: request,\n                        provider: this\n                    });\n\n                    batch.forEach((inflightRequest) => {\n                        inflightRequest.reject(error);\n                    });\n                });\n\n            }, 10);\n        }\n\n        return promise;\n    }\n}\n","/* istanbul ignore file */\n\n\"use strict\";\n\nimport { Network } from \"@ethersproject/networks\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n// Special API key provided by Nodesmith for ethers.js\nconst defaultApiKey = \"ETHERS_JS_SHARED\";\n\nexport class NodesmithProvider extends UrlJsonRpcProvider {\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey && typeof(apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey || defaultApiKey;\n    }\n\n    static getUrl(network: Network, apiKey?: any): string {\n        logger.warn(\"NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.\");\n\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc\";\n                break;\n            case \"ropsten\":\n                host = \"https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc\";\n                break;\n            case \"rinkeby\":\n                host = \"https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc\";\n                break;\n            case \"goerli\":\n                host = \"https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc\";\n                break;\n            case \"kovan\":\n                host = \"https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc\";\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return (host + \"?apiKey=\" + apiKey);\n    }\n}\n","\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { getStatic } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\n// These are load-balancer-based application IDs\nconst defaultApplicationIds: Record<string, string> = {\n    homestead: \"6004bcd10040261633ade990\",\n    ropsten: \"6004bd4d0040261633ade991\",\n    rinkeby: \"6004bda20040261633ade994\",\n    goerli: \"6004bd860040261633ade992\",\n};\n\nexport class PocketProvider extends UrlJsonRpcProvider {\n    readonly applicationId: string;\n    readonly applicationSecretKey: string;\n    readonly loadBalancer: boolean;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        // We need a bit of creativity in the constructor because\n        // Pocket uses different default API keys based on the network\n\n        if (apiKey == null) {\n            const n = getStatic<(network: Networkish) => Network>(new.target, \"getNetwork\")(network);\n            if (n) {\n                const applicationId = defaultApplicationIds[n.name];\n                if (applicationId) {\n                    apiKey = {\n                        applicationId: applicationId,\n                        loadBalancer: true\n                    };\n                }\n            }\n\n            // If there was any issue above, we don't know this network\n            if (apiKey == null) {\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n            }\n\n        }\n\n        super(network, apiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        // Most API Providers allow null to get the default configuration, but\n        // Pocket requires the network to decide the default provider, so we\n        // rely on hijacking the constructor to add a sensible default for us\n\n        if (apiKey == null) {\n            logger.throwArgumentError(\"PocketProvider.getApiKey does not support null apiKey\", \"apiKey\", apiKey);\n        }\n\n        const apiKeyObj: { applicationId: string, applicationSecretKey: string, loadBalancer: boolean } = {\n            applicationId: null,\n            loadBalancer: false,\n            applicationSecretKey: null\n        };\n\n        // Parse applicationId and applicationSecretKey\n        if (typeof (apiKey) === \"string\") {\n            apiKeyObj.applicationId = apiKey;\n\n        } else if (apiKey.applicationSecretKey != null) {\n            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"),\n                \"applicationSecretKey requires an applicationId\", \"applicationId\", apiKey.applicationId);\n            logger.assertArgument((typeof (apiKey.applicationSecretKey) === \"string\"),\n                \"invalid applicationSecretKey\", \"applicationSecretKey\", \"[REDACTED]\");\n\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;\n            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n\n        } else if (apiKey.applicationId) {\n            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"),\n                \"apiKey.applicationId must be a string\", \"apiKey.applicationId\", apiKey.applicationId);\n\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n\n        } else {\n            logger.throwArgumentError(\"unsupported PocketProvider apiKey\", \"apiKey\", apiKey);\n        }\n\n        return apiKeyObj;\n    }\n\n    static getUrl(network: Network, apiKey: any): ConnectionInfo {\n        let host: string = null;\n        switch (network ? network.name : \"unknown\") {\n            case \"homestead\":\n                host = \"eth-mainnet.gateway.pokt.network\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.gateway.pokt.network\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.gateway.pokt.network\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.gateway.pokt.network\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n\n        let url = null;\n        if (apiKey.loadBalancer) {\n            url = `https:/\\/${ host }/v1/lb/${ apiKey.applicationId }`\n        } else {\n            url = `https:/\\/${ host }/v1/${ apiKey.applicationId }`\n        }\n\n        const connection: ConnectionInfo = { url };\n\n        // Initialize empty headers\n        connection.headers = {}\n\n        // Apply application secret key\n        if (apiKey.applicationSecretKey != null) {\n            connection.user = \"\";\n            connection.password = apiKey.applicationSecretKey\n        }\n\n        return connection;\n    }\n\n    isCommunityResource(): boolean {\n        return (this.applicationId === defaultApplicationIds[this.network.name]);\n    }\n}\n","\"use strict\";\n\nimport { Networkish } from \"@ethersproject/networks\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n\n// Exported Types\nexport type ExternalProvider = {\n    isMetaMask?: boolean;\n    isStatus?: boolean;\n    host?: string;\n    path?: string;\n    sendAsync?: (request: { method: string, params?: Array<any> }, callback: (error: any, response: any) => void) => void\n    send?: (request: { method: string, params?: Array<any> }, callback: (error: any, response: any) => void) => void\n    request?: (request: { method: string, params?: Array<any> }) => Promise<any>\n}\n\nlet _nextId = 1;\n\nexport type JsonRpcFetchFunc = (method: string, params?: Array<any>) => Promise<any>;\n\ntype Web3LegacySend = (request: any, callback: (error: Error, response: any) => void) => void;\n\nfunction buildWeb3LegacyFetcher(provider: ExternalProvider, sendFunc: Web3LegacySend) : JsonRpcFetchFunc {\n    const fetcher = \"Web3LegacyFetcher\";\n\n    return function(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (_nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        return new Promise((resolve, reject) => {\n            this.emit(\"debug\", {\n                action: \"request\",\n                fetcher,\n                request: deepCopy(request),\n                provider: this\n            });\n\n            sendFunc(request, (error, response) => {\n\n                if (error) {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        fetcher,\n                        error,\n                        request,\n                        provider: this\n                    });\n\n                    return reject(error);\n                }\n\n                this.emit(\"debug\", {\n                    action: \"response\",\n                    fetcher,\n                    request,\n                    response,\n                    provider: this\n                });\n\n                if (response.error) {\n                    const error = new Error(response.error.message);\n                    (<any>error).code = response.error.code;\n                    (<any>error).data = response.error.data;\n                    return reject(error);\n                }\n\n                resolve(response.result);\n            });\n        });\n    }\n}\n\nfunction buildEip1193Fetcher(provider: ExternalProvider): JsonRpcFetchFunc {\n    return function(method: string, params: Array<any>): Promise<any> {\n        if (params == null) { params = [ ]; }\n\n        const request = { method, params };\n\n        this.emit(\"debug\", {\n            action: \"request\",\n            fetcher: \"Eip1193Fetcher\",\n            request: deepCopy(request),\n            provider: this\n        });\n\n        return provider.request(request).then((response) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                response,\n                provider: this\n            });\n\n            return response;\n\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                error,\n                provider: this\n            });\n\n            throw error;\n        });\n    }\n}\n\nexport class Web3Provider extends JsonRpcProvider {\n    readonly provider: ExternalProvider;\n    readonly jsonRpcFetchFunc: JsonRpcFetchFunc;\n\n    constructor(provider: ExternalProvider | JsonRpcFetchFunc, network?: Networkish) {\n        logger.checkNew(new.target, Web3Provider);\n\n        if (provider == null) {\n            logger.throwArgumentError(\"missing provider\", \"provider\", provider);\n        }\n\n        let path: string = null;\n        let jsonRpcFetchFunc: JsonRpcFetchFunc = null;\n        let subprovider: ExternalProvider = null;\n\n        if (typeof(provider) === \"function\") {\n            path = \"unknown:\";\n            jsonRpcFetchFunc = provider;\n\n        } else {\n            path = provider.host || provider.path || \"\";\n            if (!path && provider.isMetaMask) {\n                path = \"metamask\";\n            }\n\n            subprovider = provider;\n\n            if (provider.request) {\n                if (path === \"\") { path = \"eip-1193:\"; }\n                jsonRpcFetchFunc = buildEip1193Fetcher(provider);\n            } else if (provider.sendAsync) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));\n            } else if (provider.send) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));\n            } else {\n                logger.throwArgumentError(\"unsupported provider\", \"provider\", provider);\n            }\n\n            if (!path) { path = \"unknown:\"; }\n        }\n\n        super(path, network);\n\n        defineReadOnly(this, \"jsonRpcFetchFunc\", jsonRpcFetchFunc);\n        defineReadOnly(this, \"provider\", subprovider);\n    }\n\n    send(method: string, params: Array<any>): Promise<any> {\n        return this.jsonRpcFetchFunc(method, params);\n    }\n}\n","\"use strict\";\n\nimport {\n    Block,\n    BlockTag,\n    EventType,\n    FeeData,\n    Filter,\n    Log,\n    Listener,\n    Provider,\n    TransactionReceipt,\n    TransactionRequest,\n    TransactionResponse\n} from \"@ethersproject/abstract-provider\";\n\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\n\nimport { BaseProvider, EnsProvider, EnsResolver, Resolver } from \"./base-provider\";\n\nimport { AlchemyProvider, AlchemyWebSocketProvider } from \"./alchemy-provider\";\nimport { CloudflareProvider } from \"./cloudflare-provider\";\nimport { EtherscanProvider } from \"./etherscan-provider\";\nimport { FallbackProvider, FallbackProviderConfig } from \"./fallback-provider\";\nimport { IpcProvider } from \"./ipc-provider\";\nimport { InfuraProvider, InfuraWebSocketProvider } from \"./infura-provider\";\nimport { JsonRpcProvider, JsonRpcSigner } from \"./json-rpc-provider\";\nimport { JsonRpcBatchProvider } from \"./json-rpc-batch-provider\";\nimport { NodesmithProvider } from \"./nodesmith-provider\";\nimport { PocketProvider } from \"./pocket-provider\";\nimport { StaticJsonRpcProvider, UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Web3Provider } from \"./web3-provider\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { ExternalProvider, JsonRpcFetchFunc } from \"./web3-provider\";\n\nimport { CommunityResourcable, Formatter, isCommunityResourcable, isCommunityResource, showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n////////////////////////\n// Helper Functions\n\nfunction getDefaultProvider(network?: Networkish, options?: any): BaseProvider {\n    if (network == null) { network = \"homestead\"; }\n\n    // If passed a URL, figure out the right type of provider based on the scheme\n    if (typeof(network) === \"string\") {\n        // @TODO: Add support for IpcProvider; maybe if it ends in \".ipc\"?\n\n        // Handle http and ws (and their secure variants)\n        const match = network.match(/^(ws|http)s?:/i);\n        if (match) {\n            switch (match[1]) {\n                case \"http\":\n                    return new JsonRpcProvider(network);\n                case \"ws\":\n                    return new WebSocketProvider(network);\n                default:\n                    logger.throwArgumentError(\"unsupported URL scheme\", \"network\", network);\n            }\n        }\n    }\n\n    const n = getNetwork(network);\n    if (!n || !n._defaultProvider) {\n        logger.throwError(\"unsupported getDefaultProvider network\", Logger.errors.NETWORK_ERROR, {\n            operation: \"getDefaultProvider\",\n            network: network\n        });\n    }\n\n    return n._defaultProvider({\n        FallbackProvider,\n\n        AlchemyProvider,\n        CloudflareProvider,\n        EtherscanProvider,\n        InfuraProvider,\n        JsonRpcProvider,\n        NodesmithProvider,\n        PocketProvider,\n        Web3Provider,\n\n        IpcProvider,\n    }, options);\n}\n\n////////////////////////\n// Exports\n\nexport {\n\n    // Abstract Providers (or Abstract-ish)\n    Provider,\n    BaseProvider,\n\n    Resolver,\n\n    UrlJsonRpcProvider,\n\n    ///////////////////////\n    // Concrete Providers\n\n    FallbackProvider,\n\n    AlchemyProvider,\n    AlchemyWebSocketProvider,\n    CloudflareProvider,\n    EtherscanProvider,\n    InfuraProvider,\n    InfuraWebSocketProvider,\n    JsonRpcProvider,\n    JsonRpcBatchProvider,\n    NodesmithProvider,\n    PocketProvider,\n    StaticJsonRpcProvider,\n    Web3Provider,\n    WebSocketProvider,\n\n    IpcProvider,\n\n\n    ///////////////////////\n    // Signer\n\n    JsonRpcSigner,\n\n\n    ///////////////////////\n    // Functions\n\n    getDefaultProvider,\n    getNetwork,\n    isCommunityResource,\n    isCommunityResourcable,\n    showThrottleMessage,\n\n\n    ///////////////////////\n    // Objects\n\n    Formatter,\n\n\n    ///////////////////////\n    // Types\n\n    Block,\n    BlockTag,\n    EventType,\n    FeeData,\n    Filter,\n    Log,\n    Listener,\n    TransactionReceipt,\n    TransactionRequest,\n    TransactionResponse,\n\n    ExternalProvider,\n    JsonRpcFetchFunc,\n\n    FallbackProviderConfig,\n\n    Network,\n    Networkish,\n\n    EnsProvider,\n    EnsResolver,\n\n    CommunityResourcable\n};\n\n","'use strict'\nvar ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'\n\n// pre-compute lookup table\nvar ALPHABET_MAP = {}\nfor (var z = 0; z < ALPHABET.length; z++) {\n  var x = ALPHABET.charAt(z)\n\n  if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous')\n  ALPHABET_MAP[x] = z\n}\n\nfunction polymodStep (pre) {\n  var b = pre >> 25\n  return ((pre & 0x1FFFFFF) << 5) ^\n    (-((b >> 0) & 1) & 0x3b6a57b2) ^\n    (-((b >> 1) & 1) & 0x26508e6d) ^\n    (-((b >> 2) & 1) & 0x1ea119fa) ^\n    (-((b >> 3) & 1) & 0x3d4233dd) ^\n    (-((b >> 4) & 1) & 0x2a1462b3)\n}\n\nfunction prefixChk (prefix) {\n  var chk = 1\n  for (var i = 0; i < prefix.length; ++i) {\n    var c = prefix.charCodeAt(i)\n    if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')'\n\n    chk = polymodStep(chk) ^ (c >> 5)\n  }\n  chk = polymodStep(chk)\n\n  for (i = 0; i < prefix.length; ++i) {\n    var v = prefix.charCodeAt(i)\n    chk = polymodStep(chk) ^ (v & 0x1f)\n  }\n  return chk\n}\n\nfunction encode (prefix, words, LIMIT) {\n  LIMIT = LIMIT || 90\n  if ((prefix.length + 7 + words.length) > LIMIT) throw new TypeError('Exceeds length limit')\n\n  prefix = prefix.toLowerCase()\n\n  // determine chk mod\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') throw new Error(chk)\n\n  var result = prefix + '1'\n  for (var i = 0; i < words.length; ++i) {\n    var x = words[i]\n    if ((x >> 5) !== 0) throw new Error('Non 5-bit word')\n\n    chk = polymodStep(chk) ^ x\n    result += ALPHABET.charAt(x)\n  }\n\n  for (i = 0; i < 6; ++i) {\n    chk = polymodStep(chk)\n  }\n  chk ^= 1\n\n  for (i = 0; i < 6; ++i) {\n    var v = (chk >> ((5 - i) * 5)) & 0x1f\n    result += ALPHABET.charAt(v)\n  }\n\n  return result\n}\n\nfunction __decode (str, LIMIT) {\n  LIMIT = LIMIT || 90\n  if (str.length < 8) return str + ' too short'\n  if (str.length > LIMIT) return 'Exceeds length limit'\n\n  // don't allow mixed case\n  var lowered = str.toLowerCase()\n  var uppered = str.toUpperCase()\n  if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str\n  str = lowered\n\n  var split = str.lastIndexOf('1')\n  if (split === -1) return 'No separator character for ' + str\n  if (split === 0) return 'Missing prefix for ' + str\n\n  var prefix = str.slice(0, split)\n  var wordChars = str.slice(split + 1)\n  if (wordChars.length < 6) return 'Data too short'\n\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') return chk\n\n  var words = []\n  for (var i = 0; i < wordChars.length; ++i) {\n    var c = wordChars.charAt(i)\n    var v = ALPHABET_MAP[c]\n    if (v === undefined) return 'Unknown character ' + c\n    chk = polymodStep(chk) ^ v\n\n    // not in the checksum?\n    if (i + 6 >= wordChars.length) continue\n    words.push(v)\n  }\n\n  if (chk !== 1) return 'Invalid checksum for ' + str\n  return { prefix: prefix, words: words }\n}\n\nfunction decodeUnsafe () {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n}\n\nfunction decode (str) {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n\n  throw new Error(res)\n}\n\nfunction convert (data, inBits, outBits, pad) {\n  var value = 0\n  var bits = 0\n  var maxV = (1 << outBits) - 1\n\n  var result = []\n  for (var i = 0; i < data.length; ++i) {\n    value = (value << inBits) | data[i]\n    bits += inBits\n\n    while (bits >= outBits) {\n      bits -= outBits\n      result.push((value >> bits) & maxV)\n    }\n  }\n\n  if (pad) {\n    if (bits > 0) {\n      result.push((value << (outBits - bits)) & maxV)\n    }\n  } else {\n    if (bits >= inBits) return 'Excess padding'\n    if ((value << (outBits - bits)) & maxV) return 'Non-zero padding'\n  }\n\n  return result\n}\n\nfunction toWordsUnsafe (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n}\n\nfunction toWords (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nfunction fromWordsUnsafe (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n}\n\nfunction fromWords (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nmodule.exports = {\n  decodeUnsafe: decodeUnsafe,\n  decode: decode,\n  encode: encode,\n  toWordsUnsafe: toWordsUnsafe,\n  toWords: toWords,\n  fromWordsUnsafe: fromWordsUnsafe,\n  fromWords: fromWords\n}\n"],"names":["logger","ethDefaultProvider","network","func","providers","options","providerList","InfuraProvider","push","infura","error","EtherscanProvider","etherscan","AlchemyProvider","alchemy","PocketProvider","provider","indexOf","name","CloudflareProvider","length","FallbackProvider","quorum","renetwork","etcDefaultProvider","url","JsonRpcProvider","homestead","chainId","ensAddress","_defaultProvider","ropsten","classicMordor","networks","unspecified","mainnet","morden","testnet","rinkeby","kovan","goerli","kintsugi","classic","classicMorden","classicTestnet","classicKotti","xdai","matic","maticmum","optimism","arbitrum","bnb","bnbt","standard","throwArgumentError","value","defaultProvider","BaseX","alphabet","this","charAt","i","_alphabetMap","source","digits","carry","j","base","string","k","_leader","q","TypeError","bytes","Uint8Array","byte","undefined","Error","reverse","Base58","createTable","data","parseInt","lo","result","split","forEach","pair","comps","createRangeTable","hi","map","v","l","h","matchMap","ranges","range","d","e","Table_A_1_ranges","Table_B_1_flags","Table_B_2_ranges","s","Table_B_2_lut_abs","Table_B_2_lut_rel","Table_B_2_complex","substring","Table_C_ranges","match","toLowerCase","values","codes","code","codesTableB2","codepoint","shift","_nameprepTableB2","reduce","accum","Zeros","fill","Partition","RegExp","namehash","current","partition","label","sha256","update","digest","decode","textData","atob","charCodeAt","encode","String","fromCharCode","btoa","getUrl","href","request","method","headers","body","skipFetchSetup","mode","cache","credentials","redirect","referrer","fetch","response","arrayBuffer","key","keys","get","statusCode","status","statusMessage","statusText","staller","duration","Promise","resolve","setTimeout","bodyify","type","trim","fetchJson","connection","json","processFunc","updated","Object","filter","attemptLimit","throttleLimit","assertArgument","throttleCallback","throttleSlotInterval","allow304","timeout","allowGzip","user","password","allowInsecureAuthentication","throwError","argument","authorization","reData","dataMatch","requestBody","requestMethod","flatHeaders","header","runningTimeout","timer","promise","reject","makeError","cancel","clearTimeout","runningFetch","attempt","location","tryAgain","stall","retryAfter","Math","random","pow","serverError","throttleRetry","race","_fetchData","JSON","parse","poll","floor","ceiling","interval","done","retryLimit","check","then","oncePoll","once","onceBlock","Formatter","checkNew","formats","getDefaultFormats","address","bind","bigNumber","blockTag","hash","hex","number","transaction","accessList","allowNull","blockHash","blockNumber","transactionIndex","confirmations","from","gasPrice","maxPriorityFeePerGas","maxFeePerGas","gasLimit","to","nonce","r","uint256","creates","raw","transactionRequest","receiptLog","transactionHash","topics","arrayOf","logIndex","receipt","contractAddress","root","gasUsed","logsBloom","logs","cumulativeGasUsed","effectiveGasPrice","block","parentHash","timestamp","difficulty","miner","extraData","transactions","baseFeePerGas","blockWithTransactions","transactionResponse","fromBlock","toBlock","filterLog","removed","boolean","allowFalsish","toNumber","strict","format","author","_difficulty","_block","gas","isZero","input","networkId","replace","byzantium","Array","isArray","object","checkKey","checkValue","nullValue","replaceValue","array","isCommunityResourcable","isCommunityResource","throttleMessage","showThrottleMessage","console","log","checkTopic","topic","serializeTopics","slice","pop","unique","sorted","sort","join","getEventTag","eventName","warn","getTime","Date","PollableEvents","Event","tag","listener","coinInfos","symbol","p2pkh","p2sh","prefix","ilk","bytes32ify","toHexString","base58Encode","matcherIpfs","matchers","_parseString","_parseBytes","offset","getIpfsLink","link","Resolver","resolvedAddress","formatter","selector","parameters","tx","call","coinType","hexBytes","coinInfo","operation","words","unshift","callAddress","_fetchBytes","_getAddress","linkage","content","getText","avatar","scheme","_resolvedAddress","getAddress","owner","addr","tokenId","tokenOwner","balance","toString","metadataUrl","metadata","stringify","imageUrl","image","ipfs","swarm","keyBytes","defaultFormatter","nextPollId","BaseProvider","_events","_emitted","getFormatter","anyNetwork","detectNetwork","_networkPromise","catch","_ready","knownNetwork","emit","_maxInternalBlockNumber","_lastBlockNumber","_pollingInterval","_fastQueryDate","_network","event","maxAge","_internalBlockNumber","internalBlockNumber","respTime","reqTime","checkInternalBlockNumber","perform","networkError","getNetwork","_setFastBlockNumber","pollId","runners","_getInternalBlockNumber","pollingInterval","abs","previousBlockNumber","eventBlockNumber","runner","getTransactionReceipt","getLogs","all","polling","currentNetwork","_fastBlockNumber","_fastBlockNumberPromise","detectedNetwork","_poller","setInterval","_bootstrapPoll","clearInterval","now","getBlockNumber","_waitForTransaction","replaceable","cancelFuncs","alreadyDone","minedHandler","on","removeListener","lastBlockNumber","startBlock","scannedBlock","replaceHandler","getTransactionCount","getTransaction","mined","getBlockWithTransactions","ti","waitForTransaction","reason","eq","cancelled","replacement","_wrapTransaction","unref","addressOrName","_getBlockTag","params","position","p","expectedHash","returnedHash","wait","confirms","signedTransaction","t","hexTx","_getTransactionRequest","resolveName","blockHashOrBlockTag","includeTransactions","blockWithTxs","_getBlock","_getFilter","_getResolver","getResolver","resolver","reverseName","resolverAddress","nameOrAddress","getAvatar","pollable","_startEvent","_addEventListener","args","stopped","eventTag","apply","_stopEvent","removeAllListeners","found","padding","NegativeOne","Zero","One","MaxUint256","hexTrue","hexFalse","domainFieldTypes","version","verifyingContract","salt","domainFieldNames","checkString","domainChecks","getBaseEncoder","signed","width","boundsUpper","mask","boundsLower","add","mul","lt","gt","toTwos","padOffset","hexPadRight","id","encodeType","fields","TypedDataEncoder","types","freeze","links","parents","subtypes","uniqueNames","field","baseType","primaryTypes","n","checkCircular","child","subtype","primaryType","st","_types","encoder","_encoderCache","_getEncoder","subEncoder","getEncoder","encodedType","encodeData","hashStruct","callback","_visit","domain","domainFields","a","b","EIP712Domain","hashDomain","ensCache","visit","domainValues","domainTypes","typesWithDomain","message","errorGas","checkError","responseText","getResult","payload","getLowerCase","_constructorGuard","JsonRpcSigner","constructorGuard","addressOrIndex","UncheckedJsonRpcSigner","_address","_index","send","accounts","fromAddress","estimate","estimateGas","sender","constructor","hexlifyTransaction","sendUncheckedTransaction","populated","allowedTransactionKeys","networkOrReady","_nextId","_eventLoopCache","_cache","_uncachedDetectNetwork","getSigner","connectUnchecked","jsonrpc","action","getFeeData","feeData","prepareRequest","_startPending","_pendingFilter","self","pendingFilter","filterId","hashes","seq","listenerCount","allowExtra","allowed","WS","WebSocket","NextId","WebSocketProvider","_wsReady","_websocket","onopen","_requests","onmessage","messageEvent","sub","_subs","subscription","fauxPoll","_detectNetwork","rid","param","subIdPromise","_subIds","subId","_subscribe","emitReceipt","readyState","onerror","close","StaticJsonRpcProvider","UrlJsonRpcProvider","apiKey","checkAbstract","defaultApiKey","AlchemyWebSocketProvider","host","arguments","getTransactionPostData","maxFeePerGs","set","storageKeys","getJsonResult","checkLogTag","getBaseUrl","module","query","baseUrl","apikey","post","getPostUrl","getPostData","procFunc","payloadStr","txhash","postData","topic0","blocks","getBlock","parseFloat","ethusd","endBlock","startblock","endblock","item","timeStamp","shuffled","tmp","checkNetworks","median","maxDelta","middle","serialize","nextRid","getPromise","ForwardErrors","ForwardProperties","exposeDebugConfig","config","weight","defineProperty","start","getProcessFunc","normalize","configs","c","ceil","_highestBlockNumber","tally","count","normalizedTally","waitForSync","getRunner","currentBlockNumber","getEtherPrice","getStorageAt","providerConfigs","configOrProvider","index","stallTimeout","priority","total","sendTransaction","results","first","t0","inflightWeight","backend","waiting","errors","errorCode","props","IpcProvider","defaultProjectId","InfuraWebSocketProvider","projectId","projectSecret","apiKeyObj","JsonRpcBatchProvider","_pendingBatch","inflightRequest","_pendingBatchAggregator","batch","inflight","NodesmithProvider","defaultApplicationIds","applicationId","loadBalancer","applicationSecretKey","buildWeb3LegacyFetcher","sendFunc","fetcher","Web3Provider","path","jsonRpcFetchFunc","subprovider","isMetaMask","buildEip1193Fetcher","sendAsync","getDefaultProvider","ALPHABET","ALPHABET_MAP","z","x","polymodStep","pre","prefixChk","chk","__decode","str","LIMIT","lowered","uppered","toUpperCase","lastIndexOf","wordChars","convert","inBits","outBits","pad","bits","maxV","exports","decodeUnsafe","res","toWordsUnsafe","toWords","fromWordsUnsafe","fromWords"],"sourceRoot":""}